<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>enzo&#39;s note book</title>
    <link>http://blog.enzotech.in/</link>
    <description>sketch for random ideas</description>
    <pubDate>Wed, 03 Feb 2016 15:19:35 HKT</pubDate>
    <lastBuildDate>Wed, 03 Feb 2016 15:19:35 HKT</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>Org-page static site generator (https://github.com/kelvinh/org-page)</generator>
    <item>
      <title>用org-page尝试写点东西</title>
      <link>http://blog.enzotech.in/blog/2016/01/11/用org-page尝试写点东西/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>用org-page尝试写点东西</h1>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">背景</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
近段时间一直喜欢自己用 <code>org-mode</code> 写点东西。业务上的文档，个人的笔记等。
</p>

<p>
没有深入的了解过 <span class="underline">publish</span> 在 <code>org-mode</code> 中怎么使用，正巧遇到了 <a href="https://github.com/kelvinh/org-page"><code>org-page</code></a>, 上手很容易，就准备把自己之前的小blog给推了，用它来记录点东西。
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">安装</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
如文档上所说，使用 <code>melpa</code> 可以很容易就安装成功。 略微配置一下文件夹地址，哪些文件夹不要发布到网站上，使用的 <code>branch</code> 的名称即可。
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">迁移</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p>
虽然过去的 <code>blog</code> 写的很幼稚， 但是还有有一点 <del>历史</del> 意义的。
</p>

<p>
使用 <code>haskell</code> 写的 <code>pandoc</code> 就是文档转换界的一把金光闪闪的瑞士军刀。
</p>

<div class="org-src-container">

<pre class="src src-bash">find . -name \*.md -type f -exec pandoc  -f markdown -t org -o {}.org {} \;
</pre>
</div>

<p>
一行搞定, 然后手动加一些 <code>org-page</code> 需要的 <code>header</code> 就可以了。
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">github pages</h2>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2016/01/11/用org-page尝试写点东西/</guid>
    </item>
    <item>
      <title>Global Day Of Code Retreat</title>
      <link>http://blog.enzotech.in/blog/2013/12/17/global-day-of-code-retreat/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>Global Day Of Code Retreat</h1>


<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">主题</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
重复的做一个简单的任务，<a href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">“Conway's
Game Of Life”</a>。
</p>

<p>
全天共有六个session，每个session包含40分钟左右，以及一个或者多个的限制。每个session的目的不在于完成，目的仅仅是实践。
</p>

<p>
其余更多介绍可以参考InfoQ上<a href="http://www.infoq.com/news/2011/11/global_day_of_code_retreat">Global
Day Of Code Retreat</a>的介绍。
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">活动</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
早上9点开始，上午3个session，而后午休+交流。下午3个session，6点结束。
</p>

<p>
<i>每次活动2人pair，必须找一个不同的人。</i>
</p>

<p>
<b>session结束后将本次代码封存/删除。</b>
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">session 1</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
<b>constraint: 没有限制，用任意喜好的语言，实现这个小功能</b>
</p>

<p>
这个session的主要目的是了解整个任务是神马，要实现的大体功能是神马。
</p>

<p>
这里也简单介绍一下，这是一个0-player的游戏，给定输入，就看着这个世界如何演进就OK了。
</p>

<p>
总体在描述一个世界，有一群孤独又怕挤的神奇的小细胞们，生存条件如下:
</p>

<ul class="org-ul">
<li>活细胞周围的活细胞个数小于2个时，下一次演进会死去</li>
<li>活细胞周围的活细胞个数大于3个时，下一次演进会死去</li>
<li>活细胞周围的活细胞个数等于2/3个时，下一次演进会活着</li>
<li>死细胞周围的活细胞个数等于3个时，下一次会复活</li>
</ul>

<p>
<i>总的来说，周围活细胞个数为3时，该细胞活着。个数为2个时，活细胞依然活着。其余情况，细胞死去。</i>
</p>

<p>
没写完。
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">session 2</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
<b>constraint: 使用TDD开发</b>
</p>

<p>
该环节要求每一行代码嵌入前，必须有相关失败的用例驱使，包括类的新建，方法的新建，逻辑的新建/更新等等。
</p>

<p>
这时基本上已经熟悉了整体功能，从用例开始写起也还算顺手。
</p>

<p>
设计就是一个叫做Block的世界初始化，打印，加上一个叫做LifeScanner的神来决定每个细胞下一次的死活。
</p>

<p>
结束的时候依然没写完。
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">session 3</h3>
<div class="outline-text-3" id="text-orgheadline5">
<p>
<b>constraint: 不允许使用2维数据来保存细胞(类似使用2个List的同样不允许)</b>
</p>

<p>
听到这个条件的时候大家第一次震惊了，80%的人都在用2维数组，逻辑的一大部分是在判断数组越界。
</p>

<p>
采用的改动方式是用List保存所有存活的细胞的位置,根据位置找到周围的8个邻居，看其是否存活即可。没有边界的问题，死活完全由自身状态+周边活的邻居个数决定。
</p>

<p>
第一次写完了。
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">Lunch Break</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
<b>自由交流</b>
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">session 4</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
<b>constraint:
java语言任何方法的代码行数不超过7,ruby、scala、js等语言代码行数不超过5</b>
</p>

<p>
思路基本没变，只是不停的拆分具体的功能块。比如:
</p>

<ol class="org-ol">
<li>地图的状态取决于每个细胞的状态</li>
<li>每个细胞的状态取决于当前状态+活的邻居个数</li>
<li>活的邻居个数取决于每个邻居+其状态</li>
<li>邻居取决于自己位置</li>
</ol>

<p>
好处就是代码更内聚更单纯。
</p>

<p>
依然没做完。
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">session 5</h3>
<div class="outline-text-3" id="text-orgheadline8">
<p>
<b>constraint: 不允许使用if，三目运算等任何形式的条件语句</b>
</p>

<p>
参考思路:
</p>

<ol class="org-ol">
<li>某些情况下，直接使用表达式的值。</li>
<li>将状态和行为通过Map关联起来</li>
<li>使用多态</li>
</ol>

<p>
等等
</p>

<p>
部分取巧的方式
</p>

<ol class="org-ol">
<li>边界等异常的判断改用try-catch，丑但是Work</li>
<li>if改用while，for等形式来表达，略赖皮。</li>
</ol>

<p>
好处在于降低复杂度。个人觉得有时会增加一些代码本身的复杂性。
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">session 6</h3>
<div class="outline-text-3" id="text-orgheadline9">
<p>
<b>constraint: 不允许使用循环</b>
</p>

<p>
参考思路: <b>使用递归</b>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10">收获</h2>
<div class="outline-text-2" id="text-orgheadline10">
<p>
一整天的活动参加下来，很有乐趣。
</p>

<p>
单纯coding all day本身也是一件乐事。
</p>

<p>
认识了一些别的小伙伴。技术翻译，行政，开发，产品，各种风格的人都有出现。和各个不同风格，思想的人碰撞，交流的感触颇多。
</p>

<p>
技术上的收获也有一些，具体还是有待实践中继续积累。
</p>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2013/12/17/global-day-of-code-retreat/</guid>
    </item>
    <item>
      <title>Rails 初探</title>
      <link>http://blog.enzotech.in/blog/2013/12/20/rails-初探/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>Rails 初探</h1>
<p>
<b>首次系统的接触WEB+前端内容，好好学习一下，做一下问题的记录。</b>
</p>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">依赖</h2>
<div class="outline-text-2" id="text-orgheadline4">
</div><div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1">assetPipeLine</h3>
<div class="outline-text-3" id="text-orgheadline1">
<ul class="org-ul">
<li>js，css等文件，同时依赖多次会存在问题。具体原因还没有搞清。js的依赖全部写在了application.js中，css的依赖一样。无须在html人工导入</li>
<li>font文件的依赖，config/application.rb中添加如下代码:</li>
</ul>

<p>
{% highlight js %} config.assets.paths &lt;&lt; Rails.root.join("app",
"assets", "fonts") config.assets.precompile &lt;&lt; Proc.new { |path| if path
=~ <i>.(eot|svg|ttf|woff)\z</i> true end } {% endhighlight %}
</p>

<p>
scss中通过font-url使用即可。
</p>

<p>
{% highlight js %} font-url('glyphicons-halflings-regular.eot');<br  />
{% endhighlight %}
</p>

<ul class="org-ul">
<li>coffeeScript与scss的语法首次接触，对js，css本身的了解也不够，上手起来很是痛苦</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">View</h3>
<div class="outline-text-3" id="text-orgheadline2">
<p>
*BootStrap*果然超级好用。暂时还没有什么研究，不过拷贝过来立刻可以见到成效，感觉很好。
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">Route</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
工程的路由规则完全由config/Route.rb中内容觉得。当前只是配置了映射关系，和struts的action配置感觉没什么区别。
</p>

<p>
返回的信息类别可由调用时决定，比如welcome/index.json，即表明要获取json类型的数据。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">AJAX</h2>
<div class="outline-text-2" id="text-orgheadline5">
<p>
之所以拿出来单独说，是这个让我搞的的确很痛苦。
</p>

<p>
当然可以直接使用js(jQuery)来从页面到回调什么的完全搞定，不过有违我学习Rails的初衷，就还是按部就班的按照Rails的help上一步步尝试，各种问题。
</p>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">TAG</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
在html.erb文件中，rails推荐的写法是使用helper提供的各种tag来进行描述。
</p>

<p>
想要触发ajax请求很容易，只需要正确的用对tag就可以了。比如：
</p>

<pre class="example">
&lt;%= form_tag("/welcome/test.json",:id =&gt; "viper", remote: true)  do%&gt;
&lt;%= text_area_tag 'str', @res%&gt;
&lt;%= submit_tag 'Save' %&gt;
&lt;% end %&gt;
</pre>

<p>
现在的发现是，各种输入，在rails中都有对应的tgp来使用。在手写input的情况下，表单提交会带入不了数据，暂时还不知道是为什么。
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">CoffeeScript</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
Ajax回调的触发如下，在controller对应的js.coffee文件内，写下
</p>

<pre class="example">
$(document).ready -&gt;
$("#viper").on "ajax:success", (e, data, status, xhr) -&gt;
console.log($("#users").toArray());
console.log(data);
</pre>

<p>
类似的代码即可。我的悲剧在于html.erb文件的底部由于拷贝Bootstrap的模板还引用了JQuery，结果这个回调一直没有调通。在某次网不好的情况下，突然成功的打出了log。于是才发现是这个问题，删除之后就OK了。
</p>

<p>
一共花费了大约4+个小时来调通ajax，其中大部分都是不了解吃的亏，好疼。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8"><span class="todo TODO">TODO</span> </h2>
<div class="outline-text-2" id="text-orgheadline8">
<ol class="org-ol">
<li>将AJAX的机制再好好了解一下，用Ajax在Rails上做出一个完整的Game Of Life
网页小动画处来。</li>
<li>学习Bootstrap做一个漂亮的首页讨好一下老婆</li>
<li>多了解Rails的convention，学习其中的精华，比如看到的remote:true的配置(Unobtrusive
JavaScript)的理念，完全可以在日常中想办法借鉴一下使用的。</li>
<li>业余多了解js，css等前端相关技术</li>
</ol>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2013/12/20/rails-初探/</guid>
    </item>
    <item>
      <title>ruby的http请求小脚本</title>
      <link>http://blog.enzotech.in/blog/2013/12/31/ruby的http请求小脚本/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>ruby的http请求小脚本</h1>
<p>
经过昨天的实验，倘若接口做的事情过多时间超长，会被nginx拒绝请求返回超时。
</p>

<p>
所以用ruby做了一个批量调接口的小脚本，*有需要的人自取自改*。
</p>

<div class="org-src-container">

<pre class="src src-ruby">require "open-uri"
require "net/https"
require "uri"

cookie =
'dpadmin=360cc4800098092534fa9aedb4a78bf0b33f67e84c35660076ba6c9eab84847e0d3614348edfa4d4a8bf630529b40a28322230194c2ac52ef51c2ba4f310b9b1;
Domain=dper.com; Expires=Mon, 30-Dec-2013 22:38:45 GMT;
JSESSIONID=EA9BE36A86DCE564D7ED47571E79D82C; ' $headers =
{"cookie"=&gt;cookie}

def getFromUri(dealGroupId,uri,headers) req =
Net::HTTP::Get.new(uri,headers) res = Net::HTTP.start(uri.host) do
|http| http.request(req) end return res end

def postForm(dealGroupId,uri,headers) req =
Net::HTTP::Post.new(uri,$headers)
req.set\_form\_data(:statusId=&gt;0,:isValid=&gt;false,:dealGroupId=&gt;dealGroupId)
res = Net::HTTP.start(uri.host) do |http| http.request(req) end return
res; end

def publish(dealGroupId) uri =
URI::parse("http://tgplatform.sys.www.dianping.com/publish/fullPublish?
dealGroupId=#{dealGroupId}") res = getFromUri(dealGroupId,uri,$headers)
puts "#{dealGroupId}"+res.body end

def changeStatus(dealGroupId) uri =
URI::parse("http://tgplatform.sys.www.dianping.com/operation/setStatusId")
res = postForm(dealGroupId,uri,$headers) puts
"#{dealGroupId}"+"--status--"+res.body end

def changeIsValid(dealGroupId) uri =
URI::parse("http://tgplatform.sys.www.dianping.com/operation/setIsValid")
res = postForm(dealGroupId,uri,$headers) puts
"#{dealGroupId}"+"--valid--"+res.body end

[0].each do |dealGroupId|
 publish(dealGroupId)
end

[2100131] .each do |dealGroupId| changeStatus(dealGroupId)
changeIsValid(dealGroupId) end {% endhighlight %}
</pre>
</div>

<p>
Cookie使用自己的
</p>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2013/12/31/ruby的http请求小脚本/</guid>
    </item>
    <item>
      <title>&lt;改变未来的算法&gt; 笔记</title>
      <link>http://blog.enzotech.in/blog/2014/09/07/&lt;改变未来的算法&gt;-笔记/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>&lt;改变未来的算法&gt; 笔记</h1>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">搜索引擎</h2>
<div class="outline-text-2" id="text-orgheadline1">
<blockquote>
<p>
简要的说，一次搜索包含了: 匹配，排名。
</p>
</blockquote>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">匹配</h3>
<div class="outline-text-3" id="text-orgheadline2">
<p>
这里的主要概念就是索引。（想象一下字典） 首先需要知道词出现在哪里
</p>

<blockquote>
<p>
建立词表，记录每个词出现的地方（页面）
</p>
</blockquote>

<p>
当进行多词搜索，进行多次匹配也就可以了。但是，如果需要进行连续词搜索，那我们还需要知道词的位置。
</p>

<blockquote>
<p>
索引信息中记录词的位置（第1个，第10个，。。。）
</p>
</blockquote>

<p>
这个做完了之后，我们还可以进行元词搜索，考虑当前html的结构，=&lt;title&gt;=,=&lt;body&gt;=等标签，记录开始和闭合的节点问题，即可进行例如=key:inTitle=类型的搜索
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">PageRank</h2>
<div class="outline-text-2" id="text-orgheadline4">
</div><div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">排名</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
匹配完成后，还有一个重要的事情就是排名，找到最接近查找的内容。但是同样一个词，计算机如何去理解什么是最接近的?
可选的办法就是：*权重，计分*
</p>

<ul class="org-ul">
<li>计分:</li>
</ul>

<blockquote>
<p>
考虑使用引用次数进行计分，亦即页面超链接在其他页面中的次数。
</p>
</blockquote>

<ul class="org-ul">
<li>权重:</li>
</ul>

<p>
1000个人引用的网页和1个人引用的网页，其内容的权威程序大体上也应该可以体现。
</p>

<blockquote>
<p>
将页面权重设置为所有引用其页面的页面权重之和
</p>
</blockquote>

<p>
<b>以上看起来像解决了问题，但是这样，会出现一个问题，=循环引用=&#x2013;cycle</b>
</p>

<blockquote>
<p>
随机访问者算法。
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">公钥加密</h2>
<div class="outline-text-2" id="text-orgheadline5">
<p>
当信息交换双方协商好一种加密密钥（类似加密字典）,简单的加密也就可以进行了。下面探讨的主要是，如何公共的协商出一种密钥。
</p>

<ol class="org-ol">
<li>首先考虑一个问题，如何利用公共的信息得到一个秘密。假设有这种一个操作可以。那:</li>
</ol>

<blockquote>
<p>
操作本身可交换（协议双方的操作顺序无关）,操作本身不可逆（不唯一）
</p>
</blockquote>

<pre class="example">
3 mod 11 = 3; 5 mod 11 = 5; (3*5) mod 11 = (3 mod 11) * 5 = (5 mod 11) * 3 = 4
</pre>

<ol class="org-ol">
<li><p>
假定该操作为'*',协议双方选择一种公钥p，个人私钥p1,p2(只有自己知道)
</p>

<p>
p * p1 = r1; p * p2 = r2; key = r1 * p2 = r2 * p1
</p></li>
</ol>

<p>
这样就得出了只有协议双方才知道的密钥key.
</p>

<p>
以上的操作很类似于抽象代数里的群。
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6">纠错码</h2>
<div class="outline-text-2" id="text-orgheadline6">
<p>
本质而言，我理解，就是冗余信息进行容错。
</p>

<ol class="org-ol">
<li>简单校验和。（checkSum）</li>
<li>阶梯校验和。（通过位置+值计算）</li>
<li>将校验和进行二维应用，即可定位到错误的地方。</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7">图形识别</h2>
<div class="outline-text-2" id="text-orgheadline7">
<p>
主要模式就是 1. 训练 2. 分类
</p>

<ol class="org-ol">
<li>邻近者模式 &gt; 对每个像素做异或，寻找差异最小的模式</li>

<li>决策树 &gt; 学习过程没有太明白，分类就按照决策树遍历即可。</li>

<li>神经网络 &gt;
学习过程同样没有太明白。分类：现实问题作为输入映射到神经元，神经元的阀值触发信号，汇聚到下一级神经元，一直到最终决定。</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8">数据压缩</h2>
<div class="outline-text-2" id="text-orgheadline8">
<p>
本质上就是查找重复模式
</p>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">无损压缩</h3>
<div class="outline-text-3" id="text-orgheadline9">
<ol class="org-ol">
<li>同前</li>
<li>根据词频进行更短符号</li>
<li>TODO 霍夫曼编码</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10">有损压缩</h3>
<div class="outline-text-3" id="text-orgheadline10">
<ol class="org-ol">
<li>图片（隔行列删除像素信息）</li>
<li>JPEG（像素块内寻找模式-比如分成8*8的块状信息体）</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-2">
<h2 id="orgheadline11">数据库</h2>
<div class="outline-text-2" id="text-orgheadline11">
<ol class="org-ol">
<li>事物 作为待办事项，写redo-log，保证操作幂等。</li>
<li>复制提交</li>
<li>回滚</li>
<li>预备提交</li>
<li>虚表</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12">数字签名</h2>
<div class="outline-text-2" id="text-orgheadline12">
<p>
TODO 再仔细看一看
</p>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13">不可判定问题</h2>
<div class="outline-text-2" id="text-orgheadline13">
<p>
构造冲突的命题
</p>

<ol class="org-ol">
<li>构造一类程序用于判断程序是否会崩溃</li>
</ol>

<p>
canCrash&#x2014;&gt;canCrashWired&#x2014;&gt;crashOnSelf&#x2014;&gt;antiCrashOnSelf
</p>

<pre class="example">
|          | canCrash | canCrashWired | crashOnSelf | antiCrashOnSelf |
|----------+----------+---------------+-------------+-----------------|
| 输入条件 | 程序     | 程序          | 自身        | 自身            |
| 能崩溃   | yes      | 崩溃          | 崩溃        | yes             |
| 不能崩溃 | no       | no            | no          | 崩溃            |
|----------+----------+---------------+-------------+-----------------|
</pre>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2014/09/07/&lt;改变未来的算法&gt;-笔记/</guid>
    </item>
    <item>
      <title>common-lisp 分享笔记</title>
      <link>http://blog.enzotech.in/blog/2014/11/05/common-lisp-分享笔记/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>common-lisp 分享笔记</h1>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">Lisp</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
Lisp，最初被拼为LISP，一个历史悠久的电脑编程语言家族，以波兰表示法编写。最早由约翰·麦卡锡在1958年基于λ演算创造，是历史第二悠久的高级语言，仅次于Fortran。也是第一个函数式编程语言。
-wiki
</p>

<p>
为了研究可计算性问题，阿隆左·丘奇提出了一个被称为 lambda
演算的形式系统。这个系统本质上是一种虚拟的机器的编程语言，他的基础是一些以函数为参数和返回值的函数。函数用希腊字母
lambda 标识，这个形式系统因此得名.
1958年，基于lambda演算，约翰·麦卡锡在麻省理工学院发明了Lisp这个编程语言.约翰·麦卡锡的学生史帝芬·罗素在阅读完此论文后，认为Lisp编程语言当中的eval函数可以用机器码来实做。他在IBM
704机器上，写出了第一个LISP解释器。1962年，提姆·哈特（Tim
Hart）与麦克·莱文（Mike
Levin）在麻省理工学院，以Lisp语言，实做出第一个完整的lisp编译器。
</p>

<p>
"Hello world"
</p>

<p>
'(Hello World)
</p>

<p>
(format t "hello world")
</p>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">S表达式(symbolic expression)</h3>
<div class="outline-text-3" id="text-orgheadline2">
<p>
s-expression sexp
定义参考链接[<a href="http://en.wikipedia.org/wiki/S-expression">http://en.wikipedia.org/wiki/S-expression</a>]
</p>

<p>
一种嵌套表（树状结构）数据的表示标记 S
表达式遵循下述规则（语法）。首先，单元是用点对（Dotted
pair）来描述的。例如，car 和 cdr 都为数值 1 的单元，要写成下面这样。
</p>

<p>
(1 . 1)
</p>

<p>
其次，cdr 部分如果是一个表，则省略点和括号，也就是说：
</p>

<p>
(1 . (2 . 3))
</p>

<p>
应该写成：
</p>

<p>
(1 2 . 3)
</p>

<p>
然后，如果 cdr 部分为 nil，则省略 cdr 部分。于是：
</p>

<p>
(1 2 3 . nil)
</p>

<p>
应该写成：
</p>

<p>
(1 2 3)
</p>

<p>
通过使用前缀表达式，lisp的程序也是使用sexp来进行标记。
</p>

<pre class="example">
&lt;func name="say"&gt;
    &lt;print content="hello world"/&gt;
&lt;/func&gt;

(defun say () (print "hello world"))
</pre>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">表</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
原子就是不包含空格的符号，可以是字符，也可以是数字。表就是用小括号包含起来的原子或者表,也就是说表可以嵌套
</p>

<p>
表实际上是一个树（二叉树）。而在S表达式中， 二叉树表示为 (Left . Right)
。
</p>

<p>
如果左支是一个表，则就会成为如下形式。
</p>

<p>
((List) . Right)
</p>

<p>
如果右支是一个表，当然也可以表示为 (Left . (List))
，但是此时我们一般把点省略掉，写成
</p>

<p>
(Left List)
</p>

<p>
() nil 空表
</p>

<p>
(A . ()) (A) 同时，这也是一个有序对 (cons 'A nil)
</p>

<p>
(A B) 两个元素的表 (cons 'a (cons 'b nil))
</p>

<p>
(A B (A)) 嵌套表
</p>

<p>
'( a b c (d)) &#x2013;可以认为引号代表不求值,或者是获取表达式本身的值
</p>

<p>
(setf a (cons 'a 'b))
</p>

<p>
(car a) (cdr a)
</p>

<p>
(equal a (cons (car a)(cdr a) )) ==&gt; T
</p>

<p>
程序与数据的间隔非常小，比如
</p>

<p>
'(+ 2 2)
</p>

<p>
(eval '(+ 2 2)) ==&gt; (+ 2 2) ==&gt; 4
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">lambda 表达式</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
匿名函数 简单示例:
</p>

<p>
lambda x. x+2
</p>

<p>
(lambda x. x+2) 3 =&gt; 3+2
</p>

<p>
(lamdba x. x+2) lamdba y. y+2 =&gt; (lambda y. y+2)+2 =&gt; lambda y. (y+2)+2
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">符号</h3>
<div class="outline-text-3" id="text-orgheadline5">
<p>
参考链接:[<a href="http://acl.readthedocs.org/en/latest/zhCN/ch8-cn.html">http://acl.readthedocs.org/en/latest/zhCN/ch8-cn.html</a>]
</p>

<p>
符号是变量的名字，符号本身以对象存在。但Lisp符号的可能性，要比在多数语言仅允许作为变量名来得广泛许多。实际上，符号可以用任何字符串当作名字。可以通过调用
symbol-name 来获得符号的名字：
</p>

<p>
(= 3 3)
</p>

<p>
(setf = 3)
</p>

<p>
(= = 3) ==&gt; t
</p>

<p>
(symbol-function '=)
</p>

<p>
(symbol-value '=)
</p>

<p>
函数，宏等均是一个命名空间中的变量名。1-lisp
中，与变量共用一个命名空间。2-lisp中，与变量独立在不同的命名空间.(Common
lisp是2类，scheme是1类)
</p>

<p>
当符号是特别变量（special variable）的名字时，变量的值存在符号的 value
栏位。 symbol-value
函数引用到那个栏位，所以在符号与特殊变量的值之间，有直接的连接关系。
</p>

<p>
而对于词法变量（lexical
variables）来说，事情就完全不一样了。一个作为词法变量的符号只不过是个占位符（placeholder）。编译器会将其转为一个寄存器（register）或内存位置的引用位址。在最后编译出来的代码中，我们无法追踪这个符号。因此符号与词法变量的值之间是没有连接的；只要一有值，符号就消失了。
</p>

<p>
(let ((x 3)) (defun getSymbol () (print x)(symbol-value 'x))) ==&gt; 3 ;
Evaluation aborted on #.
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">过程抽象(函数式编程)</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
作为一种抽象手段(黑盒)，将这一过程的使用方式/目的与该过程究竟如何通过更基本的过程实现的具体细节相分离。
</p>
</div>

<div id="outline-container-orgheadline7" class="outline-4">
<h4 id="orgheadline7">函数作为参数</h4>
<div class="outline-text-4" id="text-orgheadline7">
<p>
与其将通用的和专用的混在一起,不如定义一个通用的然后把专用的部分作为参数。
</p>

<p>
实用工具。
</p>

<p>
比如遍历所有元素进行操作。 比如获取部分元素。 比如排序。
</p>

<p>
示例:
</p>

<p>
(mapcan #'print '(1 2 3 4))
</p>

<p>
(remove-if-not #'evenp '(1 2 3 4))
</p>

<p>
(remove-if-not #'(lambda (x) (= x 2)) '(1 2 3 4))
</p>

<p>
(sort '(1 2 3 0) #'&lt;)
</p>

<p>
(sort '(1 2 3 0) #'&gt;)
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-4">
<h4 id="orgheadline8">函数作为返回值</h4>
<div class="outline-text-4" id="text-orgheadline8">
<p>
如何更方便的生产函数。
</p>

<p>
例：
</p>

<p>
(remove-if #'evenp '(1 2 3 4))
</p>

<p>
(remove-if-not #'evenp '(1 2 3 4))
</p>

<p>
(defun remove-if-not2 (fn ls) (remove-if (complement fn) ls))
</p>

<p>
complement需要一个 谓词作为参数,它返回一个函数,这个函数的返回值总是和谓词得到的返回值相反
</p>

<p>
记忆化函数:
</p>

<pre class="example">
(defun memoize (fn)
    (let ((cache (make-hash-table :test #'equal)))
      #'(lambda (&amp;rest args)
          (multiple-value-bind (val win) (gethash args cache)
            (if win
                val
                (setf (gethash args cache)
                      (apply fn args)))))))
(defun fib (n)
  (if (&lt;= n 1)
      1
      (+ (fib (- n 1))
         (fib (- n 2)))))

(setf (symbol-function 'fib) (memoize #'fib))
</pre>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9">currying (多元函数规约到一元函数)</h4>
<div class="outline-text-4" id="text-orgheadline9">
<p>
lambda
演算是基于一元函数进行推演。而curry就是一个将多元函数规约到一元函数的定义。从而保证lambda演算对于任何函数都成立.
</p>

<pre class="example">
(defun curry (fn &amp;rest args)
  #'(lambda (&amp;rest args2)
      (apply fn (append args args2))))
(curry #'+ 3)

var foo = function(a) {
    return function(b) {
        return a * a + b * b;
    }
}
</pre>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10">闭包,词法作用域,动态作用域</h4>
<div class="outline-text-4" id="text-orgheadline10">
<p>
参考链接：[<a href="http://acl.readthedocs.org/en/latest/zhCN/ch6-cn.html#closures">http://acl.readthedocs.org/en/latest/zhCN/ch6-cn.html#closures</a>]
</p>

<p>
当函数引用到外部定义的变量时，这外部定义的变量称为自由变量（free
variable）。函数引用到自由的词法变量时，称之为闭包（closure）。只要函数还存在，变量就必须一起存在。闭包结合了函数与环境（environment）；无论何时，当一个函数引用到周围词法环境的某个东西时，闭包就被隐式地创建出来了。
</p>

<p>
闭包示例： 见上文。
</p>

<p>
动态作用域示例:
</p>

<pre class="example">
(defparameter *x* 100)
(let ((*x* 10))
  (defun foo ()
    (declare (special *x*))
    *x*))
(foo)
(let ((*x* 20)) (foo))
</pre>

<p>
动态作用域什么时候会派上用场呢？通常用来暂时给某个全局变量赋新值。举例来说，有
11 个变量来控制对象印出的方式，包括了 <b>print-base</b> ，缺省是 10
。如果你想要用 16 进制显示数字，你可以重新绑定 <b>print-base</b>
</p>

<p>
(let ((<b>print-base</b> 16)) (princ 32))
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">数据抽象</h3>
<div class="outline-text-3" id="text-orgheadline12">
</div><div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11">函数表达</h4>
<div class="outline-text-4" id="text-orgheadline11">
<p>
通常说来,数据结构被用来描述事物。可以用数组描述坐标,用树结构表示命令的层次结构,而用图来表示铁路网。在Lisp里,我们常会使用闭包作为表现形式。在闭包里,变量绑定可以保存信息,也能扮演在复杂数据结构中指针的角色。如果让一组闭包之间共享绑定,或者让它们之间能相互引用,那么我们就可以创建混合型的对象类型。
</p>

<p>
这就是函数语言里一个非常重要的观点：Data as
Procedure。在函数语言中，可以构造一种非常类似于对象的高阶函数：
</p>

<pre class="example">
(defun rat (x y)
   (lambda (m) (cond ((= m 0) x)
                     ((= m 1) y)
                     (t "Not Support"))))
(setf (symbol-function 'rat-instance) (rat 2 3))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">特殊形式</h3>
<div class="outline-text-3" id="text-orgheadline13">
<p>
Lisp 程序是由形式（Form）排列起来构成的。形式就是 S
表达式，它通过下面的规则来进行求值。
</p>

<p>
符号（Symbol）会被解释为变量，求出该变量所绑定的值。
</p>

<p>
除符号以外的原子，则求出其自身的值。即：整数的话就是该整数本身，字符串的话就是该字符串本身。
</p>

<p>
如果形式为表，则头一个符号为“函数名”，表中剩余的元素为参数。
</p>

<p>
Lisp 中用于赋值的 setq 特殊形式，写法如下：
</p>

<p>
(setq a 128)
</p>

<p>
setq 并不会对 a 进行求值，而是将其作为变量名来对待，这是 Lisp
语言中直接设定好的规则，像这样拥有特殊待遇的形式就被称为特殊形式。除了
setq 以外，特殊形式还有用于条件分支的 if 和用于定义局部变量的 let。
</p>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14">宏</h3>
<div class="outline-text-3" id="text-orgheadline14">
<p>
(defun test () '(+ 1 2))
</p>

<p>
(eval (test))
</p>

<p>
(defmacro test () '(+ 1 2))
</p>

<p>
(test)
</p>

<p>
宏和函数最本质的区别是：宏求值返回的是一个表，然后将表作为程序执行。而函数求值之后就结束了。
</p>

<p>
宏定义在本质上,是能生成lisp代码的函数,换句话说，一个能写程序的程序。
</p>

<p>
求值规则：
</p>

<ol class="org-ol">
<li>按照定义的要求构造表达式,接着</li>
<li>在调用宏的地方求值该表达式。</li>
</ol>

<p>
Lisp的代码的表示形式，S表达式本身就是Lisp可以方便操作的数据形式。
</p>
</div>

<div id="outline-container-orgheadline15" class="outline-4">
<h4 id="orgheadline15">特殊之处</h4>
<div class="outline-text-4" id="text-orgheadline15">
<ol class="org-ol">
<li>宏可以控制或阻止对其参数的求值</li>

<li>并且它可以展开进入到主调方的上下文中。</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-4">
<h4 id="orgheadline16">示例</h4>
<div class="outline-text-4" id="text-orgheadline16">
<pre class="example">
    (macroexpand-1 '(cond ((= x 2) (/ x 0)) (t 1)))

    (defun inc (var)
       (setq var ( 1+ var)))

    (defmacro inc (var)
       (list 'setq var (list '1+ var)))
(defmethod)

    (defmacro _f (op place &amp;rest args)
      (multiple-value-bind (vars forms var set access)
                           (get-setf-expansion place)
        `(let* (,@(mapcar #'list vars forms)
                (,(car var) (,op ,access ,@args)))
           ,set)))

    (_f memoize (symbol-function 'fib))
</pre>
</div>
</div>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2014/11/05/common-lisp-分享笔记/</guid>
    </item>
    <item>
      <title>sicp 第一章习题</title>
      <link>http://blog.enzotech.in/blog/2014/11/30/sicp-第一章习题/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>sicp 第一章习题</h1>
<div class="org-src-container">

<pre class="src src-lisp">;;; ch1.lisp ---
;;
;; Filename: ch1.lisp
;; Description:
;; Author: Liu Enze
;; Maintainer:
;; Created: Sat Nov 29 17:30:04 2014 (+0800)
;; Version:
;; Package-Requires: ()
;; Last-Updated: Wed Feb  3 15:01:26 2016 (+0800)
;;           By: Liu Enze
;;     Update #: 29
;; URL:
;; Doc URL:
;; Keywords:
;; Compatibility:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;  For all the exercises in SICP Charpter1 .
;;  Using Common Lisp (SBCL v 1.2.2)
;;  Based on SICP 2nd version
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

;;Utility
(defun id (x) x)

;;Ex1

10 ;;10
(+ 5 3 4) ;;12
(- 9 1) ;;8
(/ 6 2) ;;3
(+ (* 2 4) (- 4 6)) ;;6
(defvar a 4) ;;a
(defvar b (+ a 1)) ;;b
(+ a b (* a b)) ;;29
(= a b) ;;nil
(if (and (&gt; b a) (&lt; b (* a b)))
    b
    a) ;;5
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (t 25)) ;;6
(+ 2 (if (&gt; b a) b a)) ;;7
(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (t -1))
   (+ a 1)) ;;25

;;Ex2
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7))) ;;-37/150

;;Ex3
(defun sum-of-largest-two (a b c)
  (let ((min (min a b c)))
    (- (+ a b c) min)))

;;Ex4
(defun a-plus-abs-b (a b)
  "Return a plus b if b is positive, else return a minus b.
So, according to b, choose the fit function between + and -, then apply this
function to (a b). "
  (funcall (if (&gt; b 0) #'+ #'-) a b))

;;Ex5
"1. 0 2. infinite loop"

;;Ex6
"Infinite loop. Since before calling new-if, all the params will be evaluted, so the sprt function will always be called.
"

;;Ex7
(defun my-sqrt (n)
  "don't work for 0..."
  (labels ((good-enough (guess last)
             (&lt; (/ (abs  (- guess last)) last) 0.000001))
           (improve (guess)
             (/ (+ guess (/ n guess)) 2))
           (sqrt-iter (guess last)
             (if (good-enough guess last)
                 guess
                 (sqrt-iter (improve guess) guess))))
    (sqrt-iter 2 1)))

;;Ex8
(defun my-cube-root (n)
  "don't work for 0..."
  (labels ((good-enough (guess last)
             (&lt; (/ (abs  (- guess last)) last) 0.000001))
           (improve (guess)
             (/ (+ (/ n (* guess guess )) (* 2 guess)) 3))
           (cube-iter (guess last)
             (if (good-enough guess last)
                 guess
                 (cube-iter (improve guess) guess))))
    (cube-iter 2 1)))

;;Ex9
(defun my-+-1 (a b)
  "recursive calculation. (+ 4 5) ==&gt; (1+ (+ 3 5)) ==&gt; (1+ (1+ (+ 2 5))) ..."
  (if (= a 0)
      b
      (1+ (+ (1- a) b))))

(defun my-+-2 (a b)
  "iterate calculation. (+ 4 5) ==&gt; (+ 3 6) ==&gt; (+ 2 7) ..."
  (if (= a 0)
      b
      (+ (1- a) (1+ b))))

;;Ex10
(defun A (x y)
  (cond ((= y 0) 0)
        ((= x 0 ) (* 2 y))
        ((= y 1 ) 2)
        (t (A (1- x) (A x (1- y))))))

(A 1 10) ;; 1024
(A 2 4) ;; 65536
(A 3 3) ;; 65536

(defun f (n) (A 0 n)) ; ==&gt; f(n)=2n
(defun g (n) (A 1 n)) ; ==&gt; g(n)=2^n (n&gt;0);g(n)=0 (n=0); infinite loop (n&lt;0)
(defun h (n) (A 2 n)) ; ==&gt; h(n)=2^(2^n) (n&gt;0);h(n)=0;infinite loop (n&lt;0)

;;Ex11
(defun f-r (n)
  "recurise version of f"
  (if (&lt; n 3)
      n
      (+ (f-r (- n 1)) (* 2 (f-r (- n 2))) (* 3 (f-r (- n 3))))))
(defun f-i (n)
  "iterate version of f"
  (labels
      ((func (a b c)
         (+ a (* 2 b) (* 3 c)))
       (f-iter (n a b c)
         (if (= n 0)
             (func a b c)
             (f-iter (1- n) (func a b c) a b))))
    (if (&lt; n 3)
        n
        (f-iter (- n 3) 2 1 0))))

(dotimes (i 10) (format t "recu: ~d, iter: ~d~%" (f-r i) (f-i i)))

;;Ex 12
(defun tri (n m)
  "calculate the yanghui triangle, the n column and the m row."
  (cond ((= m 0) 1)
        ((= (1- n) m) 1)
        (t (+ (tri (1- n) (1- m)) (tri (1- n) m)))))
(dotimes (i 7) (dotimes (j i) (format t "~d " (tri i j))) (format t "~%"))

;;Ex13

;;Ex16
(defun my-exp (b n)
  "calculate b^n.  In exp-iter , a is a state"
  (labels ((exp-iter (a b n)
             (cond ((= n 0) a)
                   ((= (mod n 2) 0) (exp-iter a (* b b) (/ n 2)))
                   (t (exp-iter (* a b) (* b b) (/ (1- n) 2))))))
    (exp-iter 1 b n)))

;;Ex17 Ex18
(defun my-multi (b n)
  "calculate b*n. "
  (labels ((multi-iter (a b n)
             (cond ((= n 0) a)
                   ((= (mod n 2) 0) (multi-iter a (+ b b) (/ n 2)))
                   (t (multi-iter (+ a b) (+ b b) (/ (1- n) 2))))))
    (multi-iter 0 b n)))

;;Ex19
(defun my-fast-fib (n)
  "T is (p q | q p+q) (a b) is (0 1), T^2 makes p1=p^2+q^2,q1=pq+q(p+q)"
  (labels ((fib-iter (a b p q n)
             (cond ((= n 0) a)
                   ((evenp n) (fib-iter a b
                                        (+ (* p p) (* q q))
                                        (+ (* q q) (* 2 p q))
                                        (/ n 2)))
                   (t (fib-iter
                       (+ (* a p) (* b q))
                       (+ (* a q) (* b q) (* b p))
                       p q
                       (1- n) )))))
    (fib-iter 0 1 0 1 n)))
(dotimes (i 10) (print (my-fast-fib i)))

;;Ex21
(defun smallest-divisor (n)
  (loop for i from 2 to n
     when (= 0 (mod n i)) return i))

(mapcar #'smallest-divisor '(199 1999 19999)) ; ==&gt; (199 1999 7)

;;Ex22,23
(defun next-odd (n) (if (evenp n ) (1+ n) (+ n 2)))
(defun smallest-divisor-1 (n)
  (do ((i 2 (next-odd i)))
      ((= 0 (mod n i)) i)))
(defun my-primep (n)
  (if (= (smallest-divisor-1 n) n) t nil))
(defun next-prime (n)
  (do ((i n (next-odd i)))
      ((my-primep i) i)))

(defun smallest-primes (start num)
  (do* ((sp (next-prime start) (next-prime (1+ sp)))
        (i 1 (1+ i))
        (res (list sp) (append res (list sp))))
       ((= i num) res)))

(time (smallest-primes 1000 3))
(time (smallest-primes 10000 3))
(time (smallest-primes 100000 3))

;;Ex24-28
;;...

;;Ex29
(defun simpson (fn n a b)
  (let ((h (/ (- b a) n)))
    (do* ((i 0 (1+ i))
          (y (funcall fn (+ a (* i h))) (funcall fn (+ a (* i h))))
          (sum y (+ sum (* y (cond ((= i n) 1)
                                   ((evenp (- i n)) 2)
                                   (t 4))))))
         ((= i n) (/ (* h sum) 3)))))
(defun my-cube (x) (* x x x))
(simpson #'my-cube 100 0 1) ;; ==&gt; 1/4
(simpson #'my-cube 10000 0 1) ;; ==&gt; 1/4

;;Ex30
(defun sum (term a next b)
  "Original recusive version."
  (if (&gt; a b)
      0
      (+ (funcall term a)
         (sum term (funcall next a) next b))))
(defun my-sum (term a next b)
  "Iterate version."
  (labels ((sum-iter (cur res)
             (if (&gt; cur b)
                 res
                 (sum-iter (funcall next cur) (+ (funcall term cur) res)))))
    (sum-iter a 0)))


;;Ex31
(defun my-product (term a next b)
  "Iterate version."
  (labels ((product-iter (cur res)
             (if (&gt; cur b)
                 res
                 (product-iter (funcall next cur) (* (funcall term cur) res)))))
    (product-iter a 1)))

(defun my-product-1 (term a next b)
  "Recursive version."
  (if (&gt; a b)
      1
      (* (funcall term a)
         (my-product-1 term (funcall next a) next b))))

(defun factorial (n)
  (my-product #'(lambda (x) x) 1 #'1+ n))

(factorial 8);; ==&gt; 40320

(defun square (x) (* x x))
(defun cal-pi (n)
  (* (/ 8 (* 2 (1+ n)))
     (my-product #'(lambda (x) (square (/ (* 2 (1+ x)) (+ 1 (* 2 x)))))
                 1
                 #'1+
                 n)))

(float (cal-pi 1000)) ;; ==&gt; 3.1423774

;;Ex32
(defun accumulate (combiner base term a next b)
  (labels ((iter (cur res)
             (if (&gt; cur b)
                 res
                 (iter (funcall next cur)
                       (funcall combiner res (funcall term cur))))))
    (iter a base)))
(defun a-sum (term a next b) (accumulate #'+ 0 term a next b))
(defun a-product (term a next b) (accumulate #'* 1 term a next b))

(a-product #'(lambda (x) x) 1 #'1+ 10 );; ==&gt;3628800

;;Ex33
(defun filter-accumulate (combiner filter base term a next b)
  (labels ((iter (cur res)
             (if (&gt; cur b)
                 res
                 (iter (funcall next cur)
                       (if (funcall filter cur)
                           (funcall combiner res (funcall term cur))
                           res)))))
    (iter a base)))
(defun sum-prime (a b)
  (filter-accumulate #'+ #'my-primep 0 #'id a #'1+ b)) ;; (sum-prime 2 5) ==&gt; 10
(defun product-relatively-prime-less-than-n (n)
  (filter-accumulate #'* #'(lambda (x) (= 1 (gcd x n))) 1 #'id 1 #'1+ n)) ;;(product-relatively-prime-less-than-n 5) ==&gt; 24

;;Ex34
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (ex34-f #'ex34-f)
;; 2 fell through ETYPECAñSE expression.
;; Wanted one of (SYMBOL FUNCTION).
;;[Condition of type SB-KERNEL:CASE-FAILURE]
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun ex34-f (g)
  (funcall g 2))

;;Ex35
(defparameter *tolerance* 0.0000001)
(defun fix-point (f guess)
  (labels ((closep (v1 v2)
             (&lt; (abs (-  v1 v2)) *tolerance*))
           (try (guess)
             (let ((next (funcall f guess)))
               (if (closep next guess)
                   next
                   (try next)))))
    (try guess)))
(defun gold-radio-gen (x) (+ 1 (/ 1 x)))
(fix-point #'gold-radio-gen 1)

;;Ex36
(defun fix-point-print (f guess)
  (labels ((closep (v1 v2)
             (&lt; (abs (-  v1 v2)) *tolerance*))
           (try (guess)
             (let ((next (funcall f guess)))
               (print guess)
               (if (closep next guess)
                   next
                   (try next)))))
    (try guess)))

;;Ex37-40 ...

;;Ex41
(defun my-double (f)
  (lambda (x) (funcall f (funcall f x))))

(funcall (funcall (my-double (my-double #'my-double)) #'1+) 5)

;;Ex42
(defun compose (f g)
  (lambda (x) (funcall f (funcall g x))))

(funcall (compose #'square #'1+) 6 ) ;;==&gt; 49

;;Ex43
(defun repeated (f n)
  (if (= n 1)
      f
      (compose f (repeated f (1- n)))))

(funcall (repeated #'square 2) 5) ;==&gt; 625

;;Ex44
(defparameter *dx* 0.0001)
(defun smooth (f)
  (lambda (x) (/ (+ (funcall f (+ x *dx*))
               (funcall f (- x *dx*))
               (funcall f x))
            3)))

(defun smooth-n (f n)
  (funcall (repeated #'smooth n) f)

;;Ex45-46...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ch1.lisp ends here
</pre>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2014/11/30/sicp-第一章习题/</guid>
    </item>
    <item>
      <title>Lisp 模拟 Assembler</title>
      <link>http://blog.enzotech.in/blog/2014/12/25/lisp-模拟-assembler/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>Lisp 模拟 Assembler</h1>
<p>
通过Common Lisp，模拟assembler machine的运行。
</p>

<p>
参考SICP charpter5.
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">machine.lisp</h2>
<div class="outline-text-2" id="text-orgheadline1">
<div class="org-src-container">

<pre class="src src-lisp">;;; machine.lisp ---
;;
;; Filename: machine.lisp
;; Description:
;; Author: Liu Enze
;; Maintainer:
;; Created: Thu Dec 11 14:39:16 2014 (+0800)
;; Version:
;; Package-Requires: ()
;; Last-Updated: Wed Feb  3 15:01:10 2016 (+0800)
;;           By: Liu Enze
;;     Update #: 53
;; URL:
;; Doc URL:
;; Keywords:
;; Compatibility:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(defun make-machine (registers ops controller-text)
  (let ((machine (make-new-machine)))
    (mapcar #'(lambda (register-name)
                (funcall
                 (funcall machine 'allocate-register) register-name))
            registers)
    (funcall (funcall machine 'install-operations) ops)
    (funcall (funcall machine 'install-instruction-sequence)
             (e_assemble controller-text machine))
    machine))

(defun make-register (name)
  (let ((contents '*unassigned*))
    (lambda (message)
      (cond ((eq message 'get) contents)
            ((eq message 'set)
             (lambda (value) (setf contents value)))
            (t (error "~S :Unknown request -- REGISTER ~S" message name))))))

(defun get-contents (register)
  (funcall register 'get))

(defun set-contents (register value)
  (funcall (funcall register 'set) value))

(defun make-stack ()
  (let ((s '()))
    (flet ((push-stack (x) (setf s (cons x s)))
           (pop-stack ()
             (if (null s)
                 (error "Empty stack --- POP")
                 (let ((top (car s)))
                   (setf s (cdr s))
                   top)))
           (initialize () (setf s '()) 'done))
      (lambda (message)
        (cond ((eq message 'push) #'push-stack)
              ((eq message 'pop) (pop-stack))
              ((eq message 'initialize) (initialize))
              (t (error "~S :Unknown request --STACK" message)))))))

(defun pop-stack (stack)
  (funcall stack 'pop))

(defun push-stack (stack value)
  (funcall  (funcall stack 'push) value))

(defun instruction-execution-proc (inst)
  (cdr inst))

(defun make-new-machine ()
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (funcall stack 'initialize)))))
          (register-table
           (list (cons 'pc pc) (cons 'flag flag))))
      (labels ((allocate-register (name)
                 (if (assoc name register-table)
                     (error "Multiply defined register: ~S" name)
                     (setf register-table
                           (cons (cons name (make-register name))
                                 register-table)))
                 'register-allocated)
               (lookup-register (name)
                 (let ((val (assoc name register-table)))
                   (if val (cdr val) (error "Unknown register: ~S~%~S"
                                            name
                                            register-table))))
               (execute ()
                 (let ((insts (get-contents pc)))
                   (if (null insts)
                       'done
                       (progn
                         (funcall (instruction-execution-proc (car insts)))
                         (execute))))))
        (lambda (message)
          (cond
            ((eq message 'instructions) the-instruction-sequence)
            ((eq message 'start)
             (set-contents pc the-instruction-sequence)
             (execute))
            ((eq message 'install-instruction-sequence)
             (lambda (seq) (setf the-instruction-sequence seq)))
            ((eq message 'allocate-register) #'allocate-register)
            ((eq message 'get-register) #'lookup-register)
            ((eq message 'install-operations)
             (lambda (ops) (setf the-ops (append the-ops ops))))
            ((eq message 'stack) stack)
            ((eq message 'operations) the-ops)
            (t (error "Unknown request -- MACHINE: ~S" message))))))))

(defun start (machine)
  (funcall machine 'start))

(defun get-register (machine register-name)
  (funcall (funcall machine 'get-register) register-name))

(defun get-register-contents (machine register-name)
  (get-contents (get-register machine register-name)))

(defun set-register-contents (machine register-name value)
  (set-contents (get-register machine register-name) value)
  'done)

(defun install-instruction (machine instructions)
  (funcall (funcall machine 'install-instruction-sequence) instructions))

(defun e_assemble (controller-text machine)
  (extract-labels controller-text
                  (lambda (insts labels)
                    (update-insts! insts labels machine))))

(defun extract-labels (text receive)
  (if (null text)
      (funcall receive '() '())
      (extract-labels (cdr text)
                      (lambda (insts labels)
                        (let ((next-inst (car text)))
                          (if (symbolp next-inst)
                              (funcall receive insts
                                       (cons (make-label-entry
                                              next-inst
                                              insts)
                                             labels))
                              (funcall receive (cons
                                                (make-instruction
                                                 next-inst)
                                                insts)
                                       labels)))))))

(defun update-insts! (insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (funcall machine 'stack))
        (ops (funcall machine 'operations)))
    (loop for inst in insts collect (set-instruction-execution-proc!
                                     inst
                                     (make-execution-procedure
                                      (instruction-text inst) labels machine
                                      pc flag stack ops)))))

(defun make-instruction (text)
  (cons text '()))

(defun instruction-text (inst)
  (car inst))

(defun set-instruction-execution-proc! (inst proc)
  (setf (cdr inst) proc)
  inst)

(defun make-label-entry (label-name insts)
  (cons label-name insts))

(defun lookup-label (all-labels label-name)
  (let ((val (assoc label-name all-labels)))
    (if val
        (cdr val)
        (error "Undefined label -- ASSEMBLE: ~S" label-name))))

(defun make-execution-procedure (inst labels machine
                                 pc flag stacks ops)
  (cond ((eq (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq (car inst) 'save)
         (make-save inst machine stacks pc))
        ((eq (car inst) 'restore)
         (make-restore inst machine stacks pc))
        ((eq (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (t (error "Unknown instruction type -- ASSEMBLE : ~S" inst))))

(defun make-assign (inst machine labels operations pc)
  (let ((target (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()
        (set-contents target (funcall value-proc))
        (advance-pc pc)))))

(defun assign-reg-name (assign-instruction)
  (cadr assign-instruction))

(defun assign-value-exp (assign-instruction)
  (cddr assign-instruction))

(defun advance-pc (pc)
  (set-contents pc (cdr (get-contents pc))))

(defun make-test (inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents flag (funcall condition-proc))
            (advance-pc pc)))
        (error "Bad Test instruction -- ASSEMBLE: ~S" inst))))

(defun test-condition (test-instruction)
  (cdr test-instruction))

(defun make-branch (inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp dest)
        (let ((insts (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents pc insts)
                (advance-pc pc))))
        (error "Bad Branch instruction --ASSEMBLE: ~S" inst))))

(defun branch-dest (branch-instruction)
  (cadr branch-instruction))

(defun make-goto (inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp dest)
           (let ((insts (lookup-label labels
                                      (label-exp-label dest))))
             (lambda ()
               (set-contents pc insts))))
          ((register-exp dest)
           (let ((reg
                  (get-register machine (register-exp-reg dest))))
             (lambda () (set-contents pc (get-contents reg)))))
          (t (error "BAD GOTO instruction -- ASSEMBLE : ~S" inst)))))

(defun goto-dest (goto-instruction)
  (cadr goto-instruction))

(defun make-save (inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push-stack stack (get-contents reg))
      (advance-pc pc))))

(defun make-restore (inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents reg (pop-stack stack))
      (advance-pc pc))))

(defun stack-inst-reg-name (stack-instruction)
  (cadr stack-instruction))

(defun make-perform (inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp action)
        (let ((action-proc (make-operation-exp
                            action machine labels operations)))
          (lambda ()
            (funcall action-proc)
            (advance-pc pc))
          )
        (error "Bad PERFORM instruction -- ASSEMBLE: ~S" inst))))

(defun perform-action (inst) (cdr inst))

(defun make-primitive-exp (exp machine labels)
  (cond ((constant-exp exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp exp)
         (let ((insts (lookup-label labels
                                    (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp exp)
         (let ((r (get-register machine (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (t (error "Unknown expression type -- ASSEMBLE: ~S" exp))))

(defun register-exp (exp) (tagged-list exp 'reg))

(defun tagged-list (exp prefix)
  (eq (car exp) prefix))

(defun register-exp-reg (exp) (cadr exp))

(defun constant-exp (exp) (tagged-list exp 'const))

(defun constant-exp-value (exp) (cadr exp))

(defun label-exp (exp) (tagged-list exp 'label))

(defun label-exp-label (exp) (cadr exp))

(defun make-operation-exp (exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs (mapcar (lambda (e) (make-primitive-exp e machine labels))
                        (operation-exp-operands exp))))
    (lambda () (apply op (mapcar (lambda (p) (funcall p)) aprocs)))))

(defun operation-exp (exp)
  (and (consp exp) (tagged-list (car exp) 'op)))

(defun operation-exp-op (operation-exp)
  (cadr (car operation-exp)))

(defun operation-exp-operands (operation-exp)
  (cdr operation-exp))

(defun lookup-prim (symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation -- ASSEMBLE: ~S" symbol))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; machine.lisp ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">Usage</h2>
<div class="outline-text-2" id="text-orgheadline2">
<div class="org-src-container">

<pre class="src src-lisp">(load "./machine.lisp")

(defun expt-machine ()
  (make-machine
   '(b n val continue)
   `((= ,#'=) (- ,#'-) (* ,#'*))
   '(controller
     (assign continue (label done))
     expt-loop
     (test (op =) (reg n) (const 0))
     (branch (label answer))
     (save continue)
     (assign continue (label after-expt-n-1))
     (save n)
     (assign n (op -) (reg n) (const 1))
     (goto (label expt-loop))
     after-expt-n-1
     (restore n)
     (restore continue)
     (assign val (op *) (reg val) (reg b))
     (goto (reg continue))
     answer
     (assign val (const 1))
     (goto (reg continue))
     done)))

(defparameter *m* (expt-machine))

(set-register-contents *m* 'b 2)
;;DONE
(set-register-contents *m* 'n 2)
;;DONE
(start *m*)
;;DONE
(get-register-contents *m* 'val)
;;4
</pre>
</div>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2014/12/25/lisp-模拟-assembler/</guid>
    </item>
    <item>
      <title>爱上haskell</title>
      <link>http://blog.enzotech.in/blog/2015/02/14/爱上haskell/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>爱上haskell</h1>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">简介</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
最近有些爱上了haskell，在体验这个纯粹的函数式语言中，确实发现了一些不一样的=美感=。
</p>

<p>
话拙，直接看代码。
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">示例</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
一句话，表现力上，的确很强。 ### 快排
</p>

<div class="org-src-container">

<pre class="src src-haskell">qs :: (Ord a) =&gt; [a] -&gt; [a]
qs [] = []
qs (x:xs) = qs [gt | gt &lt;- xs, gt&gt;=x] ++ [x] ++ qs [lt | lt &lt;-xs , lt&lt;x]
</pre>
</div>

<blockquote>
<p>
快排就是将哨兵两边的数据都排好序后再拼接起来。
</p>
</blockquote>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">斐波那契数列</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
这个是最最 <b><code>惊艳</code></b> 到我的！！！
</p>

<div class="org-src-container">

<pre class="src src-haskell">fibs :: [Int]
fibs = 0 : 1 : [ a + b | (a, b) &lt;- zip fibs (tail fibs)]
</pre>
</div>

<blockquote>
<p>
翻译成中文就是，f(n) = f(n-1) + f(n-2), f(0) = 0 , f(1) = 1. 哈哈
</p>
</blockquote>

<p>
看过SICP的兄弟可能会知道，里面讲过一个延时计算的无限的流，递归的定义数据结构本身.
用commonLisp实现的话，首先要定义一个延时的流。然后基于其上可以来定义斐波的流。大概如下，可以对比一下haskell的实现。
</p>

<p>
(当然，这样的算法本质都是一样，只是表现形式上有些微的差异,
不过，haskell的，看上去，有一种奇特的帅~）
</p>

<div class="org-src-container">

<pre class="src src-lisp">(defparameter *fib*
  (cons-stream 0
               (cons-stream 1
                            (add-streams (cdr-stream *fib*)
                                         *fib*))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">实践</h2>
<div class="outline-text-2" id="text-orgheadline4">
<p>
上面的都有些偏理论，那看看稍微偏使用中的代码是什么样的。
</p>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">project euler</h3>
<div class="outline-text-3" id="text-orgheadline5">
<p>
<a href="http://projecteuler.net/problems">参考地址</a>
</p>

<p>
话不多说，直接看代码
</p>

<blockquote>
<p>
学习=haskell=两天, 可能代码不是很符合专家的美感 :)
</p>
</blockquote>
</div>

<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6"><a href="https://projecteuler.net/problem=206">euler 206</a></h4>
<div class="outline-text-4" id="text-orgheadline6">
<div class="org-src-container">

<pre class="src src-haskell">import Data.Char (intToDigit)

alternates (x:y:zs) = x : alternates zs
alternates (x:_)    = [x]
alternates _        = []

target = (map intToDigit [1..9]) ++ "0"

passes i = (alternates . show $ i^2) == target

solution = head . filter passes $ [1010101010, 1010101020 ..]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-4">
<h4 id="orgheadline7"><a href="https://projecteuler.net/problem=55">euler 55</a></h4>
<div class="outline-text-4" id="text-orgheadline7">
<div class="org-src-container">

<pre class="src src-haskell">import Data.Char
palindromicNumber :: Integer -&gt; Bool
palindromicNumber a = a == reverseNumber a

digits :: Integer -&gt; [Int]
digits = map (read . (:[])) . show

reverseNumber :: Integer -&gt; Integer
reverseNumber a = read (map intToDigit $ reverse . digits $ a) :: Integer

next :: Integer -&gt; Integer
next a = a + (reverseNumber a)

isLychrel :: Integer -&gt; Int -&gt; Int
isLychrel number times
  | times &gt;= 50 = times + 1
  | palindromicNumber $ next number = times + 1
  | otherwise = isLychrel (next number) $ times + 1

lychrel :: Integer -&gt; Maybe Int
lychrel a =
  if times &gt; 50 then Nothing else Just times
  where times = isLychrel a 0

main :: IO()
main = print $ length $ filter (== Nothing) $ map lychrel [1..10000]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-4">
<h4 id="orgheadline8"><a href="https://projecteuler.net/problem=56">euler 56</a></h4>
<div class="outline-text-4" id="text-orgheadline8">
<div class="org-src-container">

<pre class="src src-haskell">digits :: Integer -&gt; [Int]
digits = map (read . (:[])) . show

powerSum :: (Integer ,Integer) -&gt; Int
powerSum (x,y) = sum $ digits (x^y)

main :: IO()
main = print $ maximum $ map powerSum [(x,y) | x &lt;- [1..100], y &lt;-[1..100]]
</pre>
</div>

<p>
从后面的论坛里看到一个更帅的 :)
</p>

<div class="org-src-container">

<pre class="src src-haskell">import Data.Char ( digitToInt )

main = print $ maximum [sum $ map digitToInt $ show $ a^b | a &lt;- [1..99], b &lt;- [1..99]]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9"><a href="https://projecteuler.net/problem=56">euler 57</a></h4>
<div class="outline-text-4" id="text-orgheadline9">
<div class="org-src-container">

<pre class="src src-haskell">pairs :: [(Integer,Integer)]
pairs = pairsFrom (1,1)

pairsFrom :: (Integer,Integer) -&gt; [(Integer,Integer)]
pairsFrom (a,b) = (a,b):pairsFrom (a+2*b , a+b)

--In love with haskell, 这个和上面的pairs定义的效果是一样的
pairs' :: [(Integer,Integer)]
pairs' = (1,1):(map (\(x,y) -&gt; (x+2*y,x+y)) pairs')

digits :: Integer -&gt; [Int]
digits = map (read . (:[])) . show

numberLen :: Integer -&gt; Int
numberLen = length . digits

longer :: (Integer,Integer) -&gt; Bool
longer (x,y) =  numberLen x &gt; numberLen y

main ::IO()
main = print $ (length . filter longer . take 1000) pairs
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10">总结</h2>
<div class="outline-text-2" id="text-orgheadline10">
<p>
尝试了使用，情难自禁，强力推荐。有机会体验一下，应该会不虚此行。
</p>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2015/02/14/爱上haskell/</guid>
    </item>
    <item>
      <title>尝试理解Y-combinator</title>
      <link>http://blog.enzotech.in/blog/2015/03/20/尝试理解y-combinator/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>尝试理解Y-combinator</h1>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">简介</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
在一个纯粹的函数式语言环境中，只有一种元素，就是一个单参函数
</p>

<div class="org-src-container">

<pre class="src src-lisp">;; id function
(lambda (x) x)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell">-- id function in haskll
\x -&gt; x
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">问题</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
比如需要求解一个列表的长度，该如何实现。
</p>

<p>
算法规则很简单： &gt; 1. 空列表长度为0 &gt; 2. 列表长度等于 1 +
列表除了头部元素以外的部分
</p>

<p>
常规的算法实现如下:
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">common lisp</h3>
<div class="outline-text-3" id="text-orgheadline3">
<div class="org-src-container">

<pre class="src src-lisp">;; in common lisp
(defun len (ls)
  (if (null ls)
      0
      (1+ (len (cdr ls)))))
</pre>
</div>

<pre class="example">
CL-USER&gt; (len '(1 2 3))
3
CL-USER&gt; (len '())
0
</pre>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">haskell</h3>
<div class="outline-text-3" id="text-orgheadline4">
<div class="org-src-container">

<pre class="src src-haskell">len1 :: (Num b ) =&gt; [a] -&gt; b
len1 [] = 0
len1 (_:xs) = 1 + len1 xs
</pre>
</div>

<pre class="example">
λ&gt; len1 []
0
λ&gt; len1 [1,2,3]
3
</pre>

<p>
但是，如何基于纯粹的lambda表达式实现呢？
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">第一次尝试</h2>
<div class="outline-text-2" id="text-orgheadline5">
<p>
尝试翻译之前写过的实现
</p>

<div class="org-src-container">

<pre class="src src-lisp">(lambda (ls)
  (if (null ls)
      0
      (1+ (?? (cdr ls)))))
</pre>
</div>

<p>
*怎么办*，=?= 部分无法填充。因为现在这个匿名函数木有名字
</p>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">神来一笔</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
假如有一个len的实现，不就可以了么！！！！
</p>

<div class="org-src-container">

<pre class="src src-lisp">(lambda (perfectLenFunc)
  (lambda (ls)
    (if (null ls)
        0
        (1+ (perfectLenFunc (cdr ls))))))
</pre>
</div>

<p>
哇擦，要是有=perfectLenFunc=(后续简写为=plf=&#x2026;),还在这里浪费时间干神马。
</p>

<p>
*咳咳*，不急
</p>

<div class="org-src-container">

<pre class="src src-lisp">;; change to scheme, due to the function namespace
(define len1
    ((lambda (plf)
    (lambda (ls)
        (if (null? ls)
            0
            (1+ (plf (cdr ls))))))
    (lambda (ls)
    (if (null? ls)
        0
        (1+ (error (cdr ls)))))))
</pre>
</div>

<pre class="example">
scheme@(guile-user)&gt; (len1 '())
$3 = 0
scheme@(guile-user)&gt; (len1 '(a))
$4 = 1
scheme@(guile-user)&gt; (len1 '(a b))
ERROR: In procedure scm-error:
ERROR: ()
</pre>

<p>
咦，这样就可以支持长度为0的列表和长度为1的列表咧。
</p>

<p>
整体优化一下重复代码
</p>

<div class="org-src-container">

<pre class="src src-lisp">(define mk-len
  (lambda (plf)
    (lambda (ls)
        (if (null? ls)
            0
        (1+ (plf (cdr ls)))))))
(define len0 (mk-len error))
(define len1 (mk-len len0))
(define len2 (mk-len len1))
;; output
scheme@(guile-user)&gt;
(define len0 (mk-len error))
(define len1 (mk-len len0))
(define len2 (mk-len len1))
scheme@(guile-user)&gt; (len2 '(1 2))
$6 = 2
</pre>
</div>

<p>
看来,功夫不负有心人，只要足够努力,
不管多长的列表，都能写出对应的函数算出来！ &gt; 太天真了少年 （画外音）
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">神又来一笔</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
时间过去了一年，少年终于写出了可以计算长度
=14239823586=以内的列表的长度！
</p>

<p>
突然一个霹雳从天而降 &gt; 你个XX，想写到死啊！！！！ (画外音again)
</p>

<p>
咦，注意 <code>(define len0 (mk-len error))</code>,
=error=耶，岂不是说不管提供神马函数,都 不影响么
</p>

<div class="org-src-container">

<pre class="src src-lisp">(define len2 (mk-len (mk-len (mk-len mk-len))))
;; output
scheme@(guile-user)&gt;
(define len2 (mk-len (mk-len (mk-len mk-len))))
scheme@(guile-user)&gt; (len2 '(1 2))
$8 = 2
</pre>
</div>

<p>
<b>哇，那岂不是可以这样！！！</b>
</p>

<div class="org-src-container">

<pre class="src src-lisp">(define real-len
  ((lambda (mk-len)
     (mk-len mk-len))
   (lambda (mk-len)
     (lambda (l)
       (if (null? l) 0
         (1+ ((mk-len mk-len) (cdr l))))))))
scheme@(guile-user)&gt; (real-len '(1 2 3 a b d c s))
$9 = 8
</pre>
</div>

<p>
好棒！好陶醉！好满足！！！
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">神又来一笔!</h3>
<div class="outline-text-3" id="text-orgheadline8">
<p>
不过，写出来的程序看着好奇怪。好多=mk-len=,=（mk-len mk-len）=,
<b>看不懂啊</b>. 只有
</p>

<div class="org-src-container">

<pre class="src src-lisp">(lambda (l)
  (if (null? l) 0
    (1+ (?? (cdr l))))))))
</pre>
</div>

<p>
这个才是我想要的呢&#x2026; 那就想办法把=(mklen mklen)=
搞出去，做参数传进来好了👌
</p>

<div class="org-src-container">

<pre class="src src-lisp">((lambda (mk-len)
   (mk-len mk-len))
 (lambda (mk-len)
   ((lambda (len)
      (lambda (l)
        (if (null? l) 0
          (1+ (len (cdr l))))))
    (lambda (x) ((mk-len mk-len) x)))))
</pre>
</div>

<p>
哇，中间的代码看起来，有点像那么一回事了。想办法挪挪结构，更好看一点。
</p>

<div class="org-src-container">

<pre class="src src-lisp">((lambda (len')
   ((lambda (mk-len) (mk-len mk-len))
    (lambda (mk-len) (len' (lambda (x) ((mk-len mk-len) x))))))
 (lambda (len)
   (lambda (l)
     (if (null? l) 0
       (1+ (len (cdr l)))))))
</pre>
</div>

<p>
<b>BINGO</b> !!
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-2">
<h2 id="orgheadline9">the ultimate Y-Combinator</h2>
<div class="outline-text-2" id="text-orgheadline9">
<div class="org-src-container">

<pre class="src src-lisp">(define Y
  (lambda (targetFunction)
    ((lambda (f) (f f))
     (lambda (f) (targetFunction (lambda (x) ((f f) x)))))))

(define len
  ( Y (lambda (len')
        (lambda (l)
          (if (null? l) 0
            (1+ (len' (cdr l))))))))
;; output
scheme@(guile-user)&gt; (len '(a b d c dd s sf ad f))
$10 = 9
</pre>
</div>

<p>
<b>炫酷爆棚了!</b> 有没有
</p>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10">实践</h2>
<div class="outline-text-2" id="text-orgheadline10">
<p>
in haskell
</p>

<div class="org-src-container">

<pre class="src src-haskell">-- here is where miracle begins
newtype Rec a = In { out :: Rec a -&gt; a } -- for type deduction

y :: (a -&gt; a) -&gt; a
y tf = (\f -&gt; out f f) $In (\f -&gt; tf (out f f))


ylen :: (Num b) =&gt; [a]-&gt;b
ylen = y (\len' ls -&gt; if null ls then 0 else (len'.tail$ls)+1)

ysum :: (Num a) =&gt; [a] -&gt; a
ysum = y (\sum' ls -&gt; if null ls then 0 else head ls + (sum'.tail $ ls))
-- output
λ&gt; ylen [1,2,3,4]
4
λ&gt; ysum [1,2,3,4]
10
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-2">
<h2 id="orgheadline11">external links</h2>
<div class="outline-text-2" id="text-orgheadline11">
<p>
<a href="http://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator">y-combinator
in wikipedia</a>
</p>

<p>
<a href="http://mitpress.mit.edu/books/little-schemer">the litter scheme -
chapter 8</a>
</p>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2015/03/20/尝试理解y-combinator/</guid>
    </item>
  </channel>
</rss>