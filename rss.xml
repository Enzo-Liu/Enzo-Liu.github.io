<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>enzo&#39;s note book</title>
    <link>http://blog.enzotech.in/</link>
    <description>M-x (sketch for random ideas)</description>
    <pubDate>Tue, 01 Mar 2016 09:52:05 CST</pubDate>
    <lastBuildDate>Tue, 01 Mar 2016 09:52:05 CST</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>Org-page static site generator (https://github.com/kelvinh/org-page)</generator>
    <item>
      <title>179. Largest Number</title>
      <link>http://blog.enzotech.in/leetcode/179</link>
      <description><![CDATA[leetcode]]></description>
      <pubDate>2016-03-01</pubDate>
      <guid>http://blog.enzotech.in/leetcode/179</guid>
    </item>
    <item>
      <title>226. Invert Binary Tree My Submissions Question</title>
      <link>http://blog.enzotech.in/leetcode/226</link>
      <description><![CDATA[leetcode]]></description>
      <pubDate>2016-02-29</pubDate>
      <guid>http://blog.enzotech.in/leetcode/226</guid>
    </item>
    <item>
      <title>50. Pow(x, n)</title>
      <link>http://blog.enzotech.in/leetcode/50</link>
      <description><![CDATA[leetcode]]></description>
      <pubDate>2016-02-28</pubDate>
      <guid>http://blog.enzotech.in/leetcode/50</guid>
    </item>
    <item>
      <title>334.Increasing Triplet Subsequence</title>
      <link>http://blog.enzotech.in/leetcode/334</link>
      <description><![CDATA[leetcode]]></description>
      <pubDate>2016-02-25</pubDate>
      <guid>http://blog.enzotech.in/leetcode/334</guid>
    </item>
    <item>
      <title>2015新年总结</title>
      <link>http://blog.enzotech.in/blog/2016/02/08/2015新年总结</link>
      <description><![CDATA[2015 年度总结]]></description>
      <pubDate>2016-02-14</pubDate>
      <guid>http://blog.enzotech.in/blog/2016/02/08/2015新年总结</guid>
    </item>
    <item>
      <title>ruby的http请求小脚本</title>
      <link>http://blog.enzotech.in/blog/2013/12/31/ruby的http请求小脚本/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>ruby的http请求小脚本</h1>
<p>
经过昨天的实验，倘若接口做的事情过多时间超长，会被nginx拒绝请求返回超时。
</p>

<p>
所以用ruby做了一个批量调接口的小脚本，*有需要的人自取自改*。
</p>

<div class="org-src-container">

<pre class="src src-ruby">require "open-uri"
require "net/https"
require "uri"

cookie =
  'dpadmin=360cc4800098092534fa9aedb4a78bf0b33f67e84c35660076ba6c9eab84847e0d3614348edfa4d4a8bf630529b40a28322230194c2ac52ef51c2ba4f310b9b1;
Domain=dper.com; Expires=Mon, 30-Dec-2013 22:38:45 GMT;
JSESSIONID=EA9BE36A86DCE564D7ED47571E79D82C; '
$headers = {"cookie"=&gt;cookie}

def getFromUri(dealGroupId,uri,headers)
  req = Net::HTTP::Get.new(uri,headers)
  res = Net::HTTP.start(uri.host) do |http|
    http.request(req)
  end
  return res
end

def postForm(dealGroupId,uri,headers)
  req = Net::HTTP::Post.new(uri,$headers)
  req.set_form_data(:statusId=&gt;0,:isValid=&gt;false,:dealGroupId=&gt;dealGroupId)
  res = Net::HTTP.start(uri.host) do |http|
    http.request(req)
  end
  return res;
end

def publish(dealGroupId)
  uri = URI::parse("http://tgplatform.sys.www.dianping.com/publish/fullPublish? dealGroupId=#{dealGroupId}")
  res = getFromUri(dealGroupId,uri,$headers)
  puts "#{dealGroupId}"+res.body
end

def changeStatus(dealGroupId)
  uri = URI::parse("http://tgplatform.sys.www.dianping.com/operation/setStatusId")
  res = postForm(dealGroupId,uri,$headers)
  puts "#{dealGroupId}"+"--status--"+res.body
end

def changeIsValid(dealGroupId)
  uri = URI::parse("http://tgplatform.sys.www.dianping.com/operation/setIsValid")
  res = postForm(dealGroupId,uri,$headers)
  puts "#{dealGroupId}"+"--valid--"+res.body
end

[0].each do |dealGroupId|
  publish(dealGroupId)
end

[2100131] .each do |dealGroupId|
  changeStatus(dealGroupId)
  changeIsValid(dealGroupId)
end
</pre>
</div>

<p>
Cookie使用自己的
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">更新后版本</h2>
<div class="outline-text-2" id="text-orgheadline1">
<div class="org-src-container">

<pre class="src src-ruby">require "open-uri"
require "net/https"
require "uri"

cookie = 'dpadmin=360cc4800098092534fa9aedb4a78bf0b33f67e84c35660076ba6c9eab84847e0d3614348edfa4d4a8bf630529b40a28322230194c2ac52ef51c2ba4f310b9b1;
Domain=dper.com; Expires=Mon, 30-Dec-2013 22:38:45 GMT;
JSESSIONID=EA9BE36A86DCE564D7ED47571E79D82C; '
$headers = {"cookie"=&gt;cookie}

def getFromUri(dealGroupId,uri)
  req = Net::HTTP::Get.new(uri,$headers)
  Net::HTTP.start(uri.host) do |http|
    http.request(req)
  end
end

def publish(dealGroupId)
  uri = URI::parse("http://tgplatform.sys.www.dianping.com/publish/fullPublish?dealGroupId=#{dealGroupId}")
  puts "#{dealGroupId}"+getFromUri(dealGroupId,uri,$headers).body
end

def postForm(uri,form_data)
  req = Net::HTTP::Post.new(uri,$headers)
  req.set_form_data(form_data)
  Net::HTTP.start(uri.host) do |http|
    http.request(req)
  end
end

$method_name = {:Status=&gt;"operation/setStatusId",:Valid=&gt;"operation/setIsValid"}
class &lt;&lt; self
  $method_name.each do |name,value|
    define_method "change"+name.to_s do |dealGroupId,form_data|
      uri = URI::parse("http://tgplatform.sys.www.dianping.com/"+value)
      puts "#{dealGroupId}"+"--"+name.to_s+"--"+postForm(uri,form_data).body
    end
  end
end

[2079479].each do |dealGroupId|
  form_data = {:statusId=&gt;0,:isValid=&gt;false,:dealGroupId=&gt;dealGroupId}
  changeStatus(dealGroupId,form_data)
  changeValid(dealGroupId,form_data)
end
</pre>
</div>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-14</pubDate>
      <guid>http://blog.enzotech.in/blog/2013/12/31/ruby的http请求小脚本/</guid>
    </item>
    <item>
      <title>sicp 第一章习题</title>
      <link>http://blog.enzotech.in/blog/2014/11/30/sicp-第一章习题/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>sicp 第一章习题</h1>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">习题</h2>
<div class="outline-text-2" id="text-orgheadline1">
<div class="org-src-container">

<pre class="src src-common-lisp">;;; ch1.lisp ---
;;
;; Filename: ch1.lisp
;; Description:
;; Author: Liu Enze
;; Maintainer:
;; Created: Sat Nov 29 17:30:04 2014 (+0800)
;; Version:
;; Package-Requires: ()
;; Last-Updated: Sat Feb  6 08:15:56 2016 (+0800)
;;           By: Liu Enze
;;     Update #: 37
;; URL:
;; Doc URL:
;; Keywords:
;; Compatibility:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;  For all the exercises in SICP Charpter1 .
;;  Using Common Lisp (SBCL v 1.2.2)
;;  Based on SICP 2nd version
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

;;Utility
(defun id (x) x)

;;Ex1

10 ;;10
(+ 5 3 4) ;;12
(- 9 1) ;;8
(/ 6 2) ;;3
(+ (* 2 4) (- 4 6)) ;;6
(defvar a 4) ;;a
(defvar b (+ a 1)) ;;b
(+ a b (* a b)) ;;29
(= a b) ;;nil
(if (and (&gt; b a) (&lt; b (* a b)))
    b
    a) ;;5
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (t 25)) ;;6
(+ 2 (if (&gt; b a) b a)) ;;7
(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (t -1))
   (+ a 1)) ;;25

;;Ex2
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7))) ;;-37/150

;;Ex3
(defun sum-of-largest-two (a b c)
  (let ((min (min a b c)))
    (- (+ a b c) min)))

;;Ex4
(defun a-plus-abs-b (a b)
  "Return a plus b if b is positive, else return a minus b.
So, according to b, choose the fit function between + and -, then apply this
function to (a b). "
  (funcall (if (&gt; b 0) #'+ #'-) a b))

;;Ex5
"1. 0 2. infinite loop"

;;Ex6
"Infinite loop. Since before calling new-if, all the params will be evaluted, so the sprt function will always be called.
"

;;Ex7
(defun my-sqrt (n)
  "don't work for 0..."
  (labels ((good-enough (guess last)
             (&lt; (/ (abs  (- guess last)) last) 0.000001))
           (improve (guess)
             (/ (+ guess (/ n guess)) 2))
           (sqrt-iter (guess last)
             (if (good-enough guess last)
                 guess
                 (sqrt-iter (improve guess) guess))))
    (sqrt-iter 2 1)))

;;Ex8
(defun my-cube-root (n)
  "don't work for 0..."
  (labels ((good-enough (guess last)
             (&lt; (/ (abs  (- guess last)) last) 0.000001))
           (improve (guess)
             (/ (+ (/ n (* guess guess )) (* 2 guess)) 3))
           (cube-iter (guess last)
             (if (good-enough guess last)
                 guess
                 (cube-iter (improve guess) guess))))
    (cube-iter 2 1)))

;;Ex9
(defun my-+-1 (a b)
  "recursive calculation. (+ 4 5) ==&gt; (1+ (+ 3 5)) ==&gt; (1+ (1+ (+ 2 5))) ..."
  (if (= a 0)
      b
      (1+ (+ (1- a) b))))

(defun my-+-2 (a b)
  "iterate calculation. (+ 4 5) ==&gt; (+ 3 6) ==&gt; (+ 2 7) ..."
  (if (= a 0)
      b
      (+ (1- a) (1+ b))))

;;Ex10
(defun A (x y)
  (cond ((= y 0) 0)
        ((= x 0 ) (* 2 y))
        ((= y 1 ) 2)
        (t (A (1- x) (A x (1- y))))))

(A 1 10) ;; 1024
(A 2 4) ;; 65536
(A 3 3) ;; 65536

(defun f (n) (A 0 n)) ; ==&gt; f(n)=2n
(defun g (n) (A 1 n)) ; ==&gt; g(n)=2^n (n&gt;0);g(n)=0 (n=0); infinite loop (n&lt;0)
(defun h (n) (A 2 n)) ; ==&gt; h(n)=2^(2^n) (n&gt;0);h(n)=0;infinite loop (n&lt;0)

;;Ex11
(defun f-r (n)
  "recurise version of f"
  (if (&lt; n 3)
      n
      (+ (f-r (- n 1)) (* 2 (f-r (- n 2))) (* 3 (f-r (- n 3))))))
(defun f-i (n)
  "iterate version of f"
  (labels
      ((func (a b c)
         (+ a (* 2 b) (* 3 c)))
       (f-iter (n a b c)
         (if (= n 0)
             (func a b c)
             (f-iter (1- n) (func a b c) a b))))
    (if (&lt; n 3)
        n
        (f-iter (- n 3) 2 1 0))))

(dotimes (i 10) (format t "recu: ~d, iter: ~d~%" (f-r i) (f-i i)))

;;Ex 12
(defun tri (n m)
  "calculate the yanghui triangle, the n column and the m row."
  (cond ((= m 0) 1)
        ((= (1- n) m) 1)
        (t (+ (tri (1- n) (1- m)) (tri (1- n) m)))))
(dotimes (i 7) (dotimes (j i) (format t "~d " (tri i j))) (format t "~%"))

;;Ex13

;;Ex16
(defun my-exp (b n)
  "calculate b^n.  In exp-iter , a is a state"
  (labels ((exp-iter (a b n)
             (cond ((= n 0) a)
                   ((= (mod n 2) 0) (exp-iter a (* b b) (/ n 2)))
                   (t (exp-iter (* a b) (* b b) (/ (1- n) 2))))))
    (exp-iter 1 b n)))

;;Ex17 Ex18
(defun my-multi (b n)
  "calculate b*n. "
  (labels ((multi-iter (a b n)
             (cond ((= n 0) a)
                   ((= (mod n 2) 0) (multi-iter a (+ b b) (/ n 2)))
                   (t (multi-iter (+ a b) (+ b b) (/ (1- n) 2))))))
    (multi-iter 0 b n)))

;;Ex19
(defun my-fast-fib (n)
  "T is (p q | q p+q) (a b) is (0 1), T^2 makes p1=p^2+q^2,q1=pq+q(p+q)"
  (labels ((fib-iter (a b p q n)
             (cond ((= n 0) a)
                   ((evenp n) (fib-iter a b
                                        (+ (* p p) (* q q))
                                        (+ (* q q) (* 2 p q))
                                        (/ n 2)))
                   (t (fib-iter
                       (+ (* a p) (* b q))
                       (+ (* a q) (* b q) (* b p))
                       p q
                       (1- n) )))))
    (fib-iter 0 1 0 1 n)))
(dotimes (i 10) (print (my-fast-fib i)))

;;Ex21
(defun smallest-divisor (n)
  (loop for i from 2 to n
     when (= 0 (mod n i)) return i))

(mapcar #'smallest-divisor '(199 1999 19999)) ; ==&gt; (199 1999 7)

;;Ex22,23
(defun next-odd (n) (if (evenp n ) (1+ n) (+ n 2)))
(defun smallest-divisor-1 (n)
  (do ((i 2 (next-odd i)))
      ((= 0 (mod n i)) i)))
(defun my-primep (n)
  (if (= (smallest-divisor-1 n) n) t nil))
(defun next-prime (n)
  (do ((i n (next-odd i)))
      ((my-primep i) i)))

(defun smallest-primes (start num)
  (do* ((sp (next-prime start) (next-prime (1+ sp)))
        (i 1 (1+ i))
        (res (list sp) (append res (list sp))))
       ((= i num) res)))

(time (smallest-primes 1000 3))
(time (smallest-primes 10000 3))
(time (smallest-primes 100000 3))

;;Ex24-28
;;...

;;Ex29
(defun simpson (fn n a b)
  (let ((h (/ (- b a) n)))
    (do* ((i 0 (1+ i))
          (y (funcall fn (+ a (* i h))) (funcall fn (+ a (* i h))))
          (sum y (+ sum (* y (cond ((= i n) 1)
                                   ((evenp (- i n)) 2)
                                   (t 4))))))
         ((= i n) (/ (* h sum) 3)))))
(defun my-cube (x) (* x x x))
(simpson #'my-cube 100 0 1) ;; ==&gt; 1/4
(simpson #'my-cube 10000 0 1) ;; ==&gt; 1/4

;;Ex30
(defun sum (term a next b)
  "Original recusive version."
  (if (&gt; a b)
      0
      (+ (funcall term a)
         (sum term (funcall next a) next b))))
(defun my-sum (term a next b)
  "Iterate version."
  (labels ((sum-iter (cur res)
             (if (&gt; cur b)
                 res
                 (sum-iter (funcall next cur) (+ (funcall term cur) res)))))
    (sum-iter a 0)))


;;Ex31
(defun my-product (term a next b)
  "Iterate version."
  (labels ((product-iter (cur res)
             (if (&gt; cur b)
                 res
                 (product-iter (funcall next cur) (* (funcall term cur) res)))))
    (product-iter a 1)))

(defun my-product-1 (term a next b)
  "Recursive version."
  (if (&gt; a b)
      1
      (* (funcall term a)
         (my-product-1 term (funcall next a) next b))))

(defun factorial (n)
  (my-product #'(lambda (x) x) 1 #'1+ n))

(factorial 8);; ==&gt; 40320

(defun square (x) (* x x))
(defun cal-pi (n)
  (* (/ 8 (* 2 (1+ n)))
     (my-product #'(lambda (x) (square (/ (* 2 (1+ x)) (+ 1 (* 2 x)))))
                 1
                 #'1+
                 n)))

(float (cal-pi 1000)) ;; ==&gt; 3.1423774

;;Ex32
(defun accumulate (combiner base term a next b)
  (labels ((iter (cur res)
             (if (&gt; cur b)
                 res
                 (iter (funcall next cur)
                       (funcall combiner res (funcall term cur))))))
    (iter a base)))
(defun a-sum (term a next b) (accumulate #'+ 0 term a next b))
(defun a-product (term a next b) (accumulate #'* 1 term a next b))

(a-product #'(lambda (x) x) 1 #'1+ 10 );; ==&gt;3628800

;;Ex33
(defun filter-accumulate (combiner filter base term a next b)
  (labels ((iter (cur res)
             (if (&gt; cur b)
                 res
                 (iter (funcall next cur)
                       (if (funcall filter cur)
                           (funcall combiner res (funcall term cur))
                           res)))))
    (iter a base)))
(defun sum-prime (a b)
  (filter-accumulate #'+ #'my-primep 0 #'id a #'1+ b)) ;; (sum-prime 2 5) ==&gt; 10
(defun product-relatively-prime-less-than-n (n)
  (filter-accumulate #'* #'(lambda (x) (= 1 (gcd x n))) 1 #'id 1 #'1+ n)) ;;(product-relatively-prime-less-than-n 5) ==&gt; 24

;;Ex34
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (ex34-f #'ex34-f)
;; 2 fell through ETYPECAñSE expression.
;; Wanted one of (SYMBOL FUNCTION).
;;[Condition of type SB-KERNEL:CASE-FAILURE]
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun ex34-f (g)
  (funcall g 2))

;;Ex35
(defparameter *tolerance* 0.0000001)
(defun fix-point (f guess)
  (labels ((closep (v1 v2)
             (&lt; (abs (-  v1 v2)) *tolerance*))
           (try (guess)
             (let ((next (funcall f guess)))
               (if (closep next guess)
                   next
                   (try next)))))
    (try guess)))
(defun gold-radio-gen (x) (+ 1 (/ 1 x)))
(fix-point #'gold-radio-gen 1)

;;Ex36
(defun fix-point-print (f guess)
  (labels ((closep (v1 v2)
             (&lt; (abs (-  v1 v2)) *tolerance*))
           (try (guess)
             (let ((next (funcall f guess)))
               (print guess)
               (if (closep next guess)
                   next
                   (try next)))))
    (try guess)))

;;Ex37-40 ...

;;Ex41
(defun my-double (f)
  (lambda (x) (funcall f (funcall f x))))

(funcall (funcall (my-double (my-double #'my-double)) #'1+) 5)

;;Ex42
(defun compose (f g)
  (lambda (x) (funcall f (funcall g x))))

(funcall (compose #'square #'1+) 6 ) ;;==&gt; 49

;;Ex43
(defun repeated (f n)
  (if (= n 1)
      f
      (compose f (repeated f (1- n)))))

(funcall (repeated #'square 2) 5) ;==&gt; 625

;;Ex44
(defparameter *dx* 0.0001)
(defun smooth (f)
  (lambda (x) (/ (+ (funcall f (+ x *dx*))
               (funcall f (- x *dx*))
               (funcall f x))
            3)))

(defun smooth-n (f n)
  (funcall (repeated #'smooth n) f)

;;Ex45-46...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ch1.lisp ends here
</pre>
</div>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-08</pubDate>
      <guid>http://blog.enzotech.in/blog/2014/11/30/sicp-第一章习题/</guid>
    </item>
    <item>
      <title>Lisp 模拟 Assembler</title>
      <link>http://blog.enzotech.in/blog/2014/12/25/lisp-模拟-assembler/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>Lisp 模拟 Assembler</h1>
<p>
通过Common Lisp，模拟assembler machine的运行。
</p>

<p>
参考SICP charpter5.
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">machine.lisp</h2>
<div class="outline-text-2" id="text-orgheadline1">
<div class="org-src-container">

<pre class="src src-common-lisp">;;; machine.lisp ---
;;
;; Filename: machine.lisp
;; Description:
;; Author: Liu Enze
;; Maintainer:
;; Created: Thu Dec 11 14:39:16 2014 (+0800)
;; Version:
;; Package-Requires: ()
;; Last-Updated: Wed Feb  3 19:03:37 2016 (+0800)
;;           By: Liu Enze
;;     Update #: 55
;; URL:
;; Doc URL:
;; Keywords:
;; Compatibility:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(defun make-machine (registers ops controller-text)
  (let ((machine (make-new-machine)))
    (mapcar #'(lambda (register-name)
                (funcall
                 (funcall machine 'allocate-register) register-name))
            registers)
    (funcall (funcall machine 'install-operations) ops)
    (funcall (funcall machine 'install-instruction-sequence)
             (e_assemble controller-text machine))
    machine))

(defun make-register (name)
  (let ((contents '*unassigned*))
    (lambda (message)
      (cond ((eq message 'get) contents)
            ((eq message 'set)
             (lambda (value) (setf contents value)))
            (t (error "~S :Unknown request -- REGISTER ~S" message name))))))

(defun get-contents (register)
  (funcall register 'get))

(defun set-contents (register value)
  (funcall (funcall register 'set) value))

(defun make-stack ()
  (let ((s '()))
    (flet ((push-stack (x) (setf s (cons x s)))
           (pop-stack ()
             (if (null s)
                 (error "Empty stack --- POP")
                 (let ((top (car s)))
                   (setf s (cdr s))
                   top)))
           (initialize () (setf s '()) 'done))
      (lambda (message)
        (cond ((eq message 'push) #'push-stack)
              ((eq message 'pop) (pop-stack))
              ((eq message 'initialize) (initialize))
              (t (error "~S :Unknown request --STACK" message)))))))

(defun pop-stack (stack)
  (funcall stack 'pop))

(defun push-stack (stack value)
  (funcall  (funcall stack 'push) value))

(defun instruction-execution-proc (inst)
  (cdr inst))

(defun make-new-machine ()
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (funcall stack 'initialize)))))
          (register-table
           (list (cons 'pc pc) (cons 'flag flag))))
      (labels ((allocate-register (name)
                 (if (assoc name register-table)
                     (error "Multiply defined register: ~S" name)
                     (setf register-table
                           (cons (cons name (make-register name))
                                 register-table)))
                 'register-allocated)
               (lookup-register (name)
                 (let ((val (assoc name register-table)))
                   (if val (cdr val) (error "Unknown register: ~S~%~S"
                                            name
                                            register-table))))
               (execute ()
                 (let ((insts (get-contents pc)))
                   (if (null insts)
                       'done
                       (progn
                         (funcall (instruction-execution-proc (car insts)))
                         (execute))))))
        (lambda (message)
          (cond
            ((eq message 'instructions) the-instruction-sequence)
            ((eq message 'start)
             (set-contents pc the-instruction-sequence)
             (execute))
            ((eq message 'install-instruction-sequence)
             (lambda (seq) (setf the-instruction-sequence seq)))
            ((eq message 'allocate-register) #'allocate-register)
            ((eq message 'get-register) #'lookup-register)
            ((eq message 'install-operations)
             (lambda (ops) (setf the-ops (append the-ops ops))))
            ((eq message 'stack) stack)
            ((eq message 'operations) the-ops)
            (t (error "Unknown request -- MACHINE: ~S" message))))))))

(defun start (machine)
  (funcall machine 'start))

(defun get-register (machine register-name)
  (funcall (funcall machine 'get-register) register-name))

(defun get-register-contents (machine register-name)
  (get-contents (get-register machine register-name)))

(defun set-register-contents (machine register-name value)
  (set-contents (get-register machine register-name) value)
  'done)

(defun install-instruction (machine instructions)
  (funcall (funcall machine 'install-instruction-sequence) instructions))

(defun e_assemble (controller-text machine)
  (extract-labels controller-text
                  (lambda (insts labels)
                    (update-insts! insts labels machine))))

(defun extract-labels (text receive)
  (if (null text)
      (funcall receive '() '())
      (extract-labels (cdr text)
                      (lambda (insts labels)
                        (let ((next-inst (car text)))
                          (if (symbolp next-inst)
                              (funcall receive insts
                                       (cons (make-label-entry
                                              next-inst
                                              insts)
                                             labels))
                              (funcall receive (cons
                                                (make-instruction
                                                 next-inst)
                                                insts)
                                       labels)))))))

(defun update-insts! (insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (funcall machine 'stack))
        (ops (funcall machine 'operations)))
    (loop for inst in insts collect (set-instruction-execution-proc!
                                     inst
                                     (make-execution-procedure
                                      (instruction-text inst) labels machine
                                      pc flag stack ops)))))

(defun make-instruction (text)
  (cons text '()))

(defun instruction-text (inst)
  (car inst))

(defun set-instruction-execution-proc! (inst proc)
  (setf (cdr inst) proc)
  inst)

(defun make-label-entry (label-name insts)
  (cons label-name insts))

(defun lookup-label (all-labels label-name)
  (let ((val (assoc label-name all-labels)))
    (if val
        (cdr val)
        (error "Undefined label -- ASSEMBLE: ~S" label-name))))

(defun make-execution-procedure (inst labels machine
                                 pc flag stacks ops)
  (cond ((eq (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq (car inst) 'save)
         (make-save inst machine stacks pc))
        ((eq (car inst) 'restore)
         (make-restore inst machine stacks pc))
        ((eq (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (t (error "Unknown instruction type -- ASSEMBLE : ~S" inst))))

(defun make-assign (inst machine labels operations pc)
  (let ((target (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()
        (set-contents target (funcall value-proc))
        (advance-pc pc)))))

(defun assign-reg-name (assign-instruction)
  (cadr assign-instruction))

(defun assign-value-exp (assign-instruction)
  (cddr assign-instruction))

(defun advance-pc (pc)
  (set-contents pc (cdr (get-contents pc))))

(defun make-test (inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents flag (funcall condition-proc))
            (advance-pc pc)))
        (error "Bad Test instruction -- ASSEMBLE: ~S" inst))))

(defun test-condition (test-instruction)
  (cdr test-instruction))

(defun make-branch (inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp dest)
        (let ((insts (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents pc insts)
                (advance-pc pc))))
        (error "Bad Branch instruction --ASSEMBLE: ~S" inst))))

(defun branch-dest (branch-instruction)
  (cadr branch-instruction))

(defun make-goto (inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp dest)
           (let ((insts (lookup-label labels
                                      (label-exp-label dest))))
             (lambda ()
               (set-contents pc insts))))
          ((register-exp dest)
           (let ((reg
                  (get-register machine (register-exp-reg dest))))
             (lambda () (set-contents pc (get-contents reg)))))
          (t (error "BAD GOTO instruction -- ASSEMBLE : ~S" inst)))))

(defun goto-dest (goto-instruction)
  (cadr goto-instruction))

(defun make-save (inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push-stack stack (get-contents reg))
      (advance-pc pc))))

(defun make-restore (inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents reg (pop-stack stack))
      (advance-pc pc))))

(defun stack-inst-reg-name (stack-instruction)
  (cadr stack-instruction))

(defun make-perform (inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp action)
        (let ((action-proc (make-operation-exp
                            action machine labels operations)))
          (lambda ()
            (funcall action-proc)
            (advance-pc pc))
          )
        (error "Bad PERFORM instruction -- ASSEMBLE: ~S" inst))))

(defun perform-action (inst) (cdr inst))

(defun make-primitive-exp (exp machine labels)
  (cond ((constant-exp exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp exp)
         (let ((insts (lookup-label labels
                                    (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp exp)
         (let ((r (get-register machine (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (t (error "Unknown expression type -- ASSEMBLE: ~S" exp))))

(defun register-exp (exp) (tagged-list exp 'reg))

(defun tagged-list (exp prefix)
  (eq (car exp) prefix))

(defun register-exp-reg (exp) (cadr exp))

(defun constant-exp (exp) (tagged-list exp 'const))

(defun constant-exp-value (exp) (cadr exp))

(defun label-exp (exp) (tagged-list exp 'label))

(defun label-exp-label (exp) (cadr exp))

(defun make-operation-exp (exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs (mapcar (lambda (e) (make-primitive-exp e machine labels))
                        (operation-exp-operands exp))))
    (lambda () (apply op (mapcar (lambda (p) (funcall p)) aprocs)))))

(defun operation-exp (exp)
  (and (consp exp) (tagged-list (car exp) 'op)))

(defun operation-exp-op (operation-exp)
  (cadr (car operation-exp)))

(defun operation-exp-operands (operation-exp)
  (cdr operation-exp))

(defun lookup-prim (symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation -- ASSEMBLE: ~S" symbol))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; machine.lisp ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">Usage</h2>
<div class="outline-text-2" id="text-orgheadline2">
<div class="org-src-container">

<pre class="src src-common-lisp">(load "./machine.lisp")

(defun expt-machine ()
  (make-machine
   '(b n val continue)
   `((= ,#'=) (- ,#'-) (* ,#'*))
   '(controller
     (assign continue (label done))
     expt-loop
     (test (op =) (reg n) (const 0))
     (branch (label answer))
     (save continue)
     (assign continue (label after-expt-n-1))
     (save n)
     (assign n (op -) (reg n) (const 1))
     (goto (label expt-loop))
     after-expt-n-1
     (restore n)
     (restore continue)
     (assign val (op *) (reg val) (reg b))
     (goto (reg continue))
     answer
     (assign val (const 1))
     (goto (reg continue))
     done)))

(defparameter *m* (expt-machine))

(set-register-contents *m* 'b 2)
;;DONE
(set-register-contents *m* 'n 2)
;;DONE
(start *m*)
;;DONE
(get-register-contents *m* 'val)
;;4
</pre>
</div>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-08</pubDate>
      <guid>http://blog.enzotech.in/blog/2014/12/25/lisp-模拟-assembler/</guid>
    </item>
    <item>
      <title>用org-page尝试写点东西</title>
      <link>http://blog.enzotech.in/blog/2016/01/11/用org-page尝试写点东西/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>用org-page尝试写点东西</h1>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">背景</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
近段时间一直喜欢自己用 <code>org-mode</code> 写点东西。业务上的文档，个人的笔记等。
</p>

<p>
没有深入的了解过 <span class="underline">publish</span> 在 <code>org-mode</code> 中怎么使用，正巧遇到了 <a href="https://github.com/kelvinh/org-page"><code>org-page</code></a>, 上手很容易，就准备把自己之前的小blog给推了，用它来记录点东西。
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">安装</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
如文档上所说，使用 <code>melpa</code> 可以很容易就安装成功。 略微配置一下文件夹地址，哪些文件夹不要发布到网站上，使用的 <code>branch</code> 的名称即可。
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">迁移</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p>
虽然过去的 <code>blog</code> 写的很幼稚， 但是还有有一点 <del>历史</del> 意义的。
</p>

<p>
使用 <code>haskell</code> 写的 <code>pandoc</code> 就是文档转换界的一把金光闪闪的瑞士军刀。
</p>

<div class="org-src-container">

<pre class="src src-bash">find . -name \*.md -type f -exec pandoc  -f markdown -t org -o {}.org {} \;
</pre>
</div>

<p>
一行搞定, 然后手动加一些 <code>org-page</code> 需要的 <code>header</code> 就可以了。
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">github pages</h2>
<div class="outline-text-2" id="text-orgheadline4">
<p>
原先就是使用 <code>jekyll</code> 托管在 <code>github page</code> 上， 现在只需要把 <code>master</code> 分支的文件替换成 <code>org-page</code> 生成的文件就可以了。
</p>

<div class="org-src-container">

<pre class="src src-bash">git checkout master
find . -name \* | grep -v ".git" | xargs rm -rf
git add . &amp;&amp; git commit -m “clear all"
git checkout source
</pre>
</div>

<p>
然后在 <code>emacs</code> 里执行
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(op/do-publication t nil nil t)
</pre>
</div>

<p>
That's done.
</p>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2016/01/11/用org-page尝试写点东西/</guid>
    </item>
    <item>
      <title>Global Day Of Code Retreat</title>
      <link>http://blog.enzotech.in/blog/2013/12/17/global-day-of-code-retreat/</link>
      <description><![CDATA[<div>
<div class="post">
<h1>Global Day Of Code Retreat</h1>


<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">主题</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
重复的做一个简单的任务，<a href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">“Conway's
Game Of Life”</a>。
</p>

<p>
全天共有六个session，每个session包含40分钟左右，以及一个或者多个的限制。每个session的目的不在于完成，目的仅仅是实践。
</p>

<p>
其余更多介绍可以参考InfoQ上<a href="http://www.infoq.com/news/2011/11/global_day_of_code_retreat">Global
Day Of Code Retreat</a>的介绍。
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">活动</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
早上9点开始，上午3个session，而后午休+交流。下午3个session，6点结束。
</p>

<p>
<i>每次活动2人pair，必须找一个不同的人。</i>
</p>

<p>
<b>session结束后将本次代码封存/删除。</b>
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">session 1</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
<b>constraint: 没有限制，用任意喜好的语言，实现这个小功能</b>
</p>

<p>
这个session的主要目的是了解整个任务是神马，要实现的大体功能是神马。
</p>

<p>
这里也简单介绍一下，这是一个0-player的游戏，给定输入，就看着这个世界如何演进就OK了。
</p>

<p>
总体在描述一个世界，有一群孤独又怕挤的神奇的小细胞们，生存条件如下:
</p>

<ul class="org-ul">
<li>活细胞周围的活细胞个数小于2个时，下一次演进会死去</li>
<li>活细胞周围的活细胞个数大于3个时，下一次演进会死去</li>
<li>活细胞周围的活细胞个数等于2/3个时，下一次演进会活着</li>
<li>死细胞周围的活细胞个数等于3个时，下一次会复活</li>
</ul>

<p>
<i>总的来说，周围活细胞个数为3时，该细胞活着。个数为2个时，活细胞依然活着。其余情况，细胞死去。</i>
</p>

<p>
没写完。
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">session 2</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
<b>constraint: 使用TDD开发</b>
</p>

<p>
该环节要求每一行代码嵌入前，必须有相关失败的用例驱使，包括类的新建，方法的新建，逻辑的新建/更新等等。
</p>

<p>
这时基本上已经熟悉了整体功能，从用例开始写起也还算顺手。
</p>

<p>
设计就是一个叫做Block的世界初始化，打印，加上一个叫做LifeScanner的神来决定每个细胞下一次的死活。
</p>

<p>
结束的时候依然没写完。
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">session 3</h3>
<div class="outline-text-3" id="text-orgheadline5">
<p>
<b>constraint: 不允许使用2维数据来保存细胞(类似使用2个List的同样不允许)</b>
</p>

<p>
听到这个条件的时候大家第一次震惊了，80%的人都在用2维数组，逻辑的一大部分是在判断数组越界。
</p>

<p>
采用的改动方式是用List保存所有存活的细胞的位置,根据位置找到周围的8个邻居，看其是否存活即可。没有边界的问题，死活完全由自身状态+周边活的邻居个数决定。
</p>

<p>
第一次写完了。
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">Lunch Break</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
<b>自由交流</b>
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">session 4</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
<b>constraint:
java语言任何方法的代码行数不超过7,ruby、scala、js等语言代码行数不超过5</b>
</p>

<p>
思路基本没变，只是不停的拆分具体的功能块。比如:
</p>

<ol class="org-ol">
<li>地图的状态取决于每个细胞的状态</li>
<li>每个细胞的状态取决于当前状态+活的邻居个数</li>
<li>活的邻居个数取决于每个邻居+其状态</li>
<li>邻居取决于自己位置</li>
</ol>

<p>
好处就是代码更内聚更单纯。
</p>

<p>
依然没做完。
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">session 5</h3>
<div class="outline-text-3" id="text-orgheadline8">
<p>
<b>constraint: 不允许使用if，三目运算等任何形式的条件语句</b>
</p>

<p>
参考思路:
</p>

<ol class="org-ol">
<li>某些情况下，直接使用表达式的值。</li>
<li>将状态和行为通过Map关联起来</li>
<li>使用多态</li>
</ol>

<p>
等等
</p>

<p>
部分取巧的方式
</p>

<ol class="org-ol">
<li>边界等异常的判断改用try-catch，丑但是Work</li>
<li>if改用while，for等形式来表达，略赖皮。</li>
</ol>

<p>
好处在于降低复杂度。个人觉得有时会增加一些代码本身的复杂性。
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">session 6</h3>
<div class="outline-text-3" id="text-orgheadline9">
<p>
<b>constraint: 不允许使用循环</b>
</p>

<p>
参考思路: <b>使用递归</b>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10">收获</h2>
<div class="outline-text-2" id="text-orgheadline10">
<p>
一整天的活动参加下来，很有乐趣。
</p>

<p>
单纯coding all day本身也是一件乐事。
</p>

<p>
认识了一些别的小伙伴。技术翻译，行政，开发，产品，各种风格的人都有出现。和各个不同风格，思想的人碰撞，交流的感触颇多。
</p>

<p>
技术上的收获也有一些，具体还是有待实践中继续积累。
</p>
</div>
</div>

</div>
</div>]]></description>
      <pubDate>2016-02-03</pubDate>
      <guid>http://blog.enzotech.in/blog/2013/12/17/global-day-of-code-retreat/</guid>
    </item>
  </channel>
</rss>