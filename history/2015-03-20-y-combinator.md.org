#+TITLE: å°è¯•ç†è§£Y-combinator
#+AUTHOR: enzo liu
#+EMAIL:  liuenze6516@gmail.com
#+DATE: 2015-03-20
#+OPTIONS:   H:3 toc:nil num:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+TAGS: lisp haskell y-combinator lambda

** ç®€ä»‹

åœ¨ä¸€ä¸ªçº¯ç²¹çš„å‡½æ•°å¼è¯­è¨€ç¯å¢ƒä¸­ï¼Œåªæœ‰ä¸€ç§å…ƒç´ ï¼Œå°±æ˜¯ä¸€ä¸ªå•å‚å‡½æ•°

#+BEGIN_SRC lisp
    ;; id function
    (lambda (x) x)
#+END_SRC

#+BEGIN_SRC haskell
    -- id function in haskll
    \x -> x
#+END_SRC

** é—®é¢˜

æ¯”å¦‚éœ€è¦æ±‚è§£ä¸€ä¸ªåˆ—è¡¨çš„é•¿åº¦ï¼Œè¯¥å¦‚ä½•å®ç°ã€‚

ç®—æ³•è§„åˆ™å¾ˆç®€å•ï¼š > 1. ç©ºåˆ—è¡¨é•¿åº¦ä¸º0 > 2. åˆ—è¡¨é•¿åº¦ç­‰äº 1 +
åˆ—è¡¨é™¤äº†å¤´éƒ¨å…ƒç´ ä»¥å¤–çš„éƒ¨åˆ†

å¸¸è§„çš„ç®—æ³•å®ç°å¦‚ä¸‹:

*** common lisp

#+BEGIN_SRC lisp
    ;; in common lisp
    (defun len (ls)
      (if (null ls)
          0
          (1+ (len (cdr ls)))))
#+END_SRC

#+BEGIN_EXAMPLE
    CL-USER> (len '(1 2 3))
    3
    CL-USER> (len '())
    0
#+END_EXAMPLE

*** haskell

#+BEGIN_SRC haskell
    len1 :: (Num b ) => [a] -> b
    len1 [] = 0
    len1 (_:xs) = 1 + len1 xs
#+END_SRC

#+BEGIN_EXAMPLE
    Î»> len1 []
    0
    Î»> len1 [1,2,3]
    3
#+END_EXAMPLE

ä½†æ˜¯ï¼Œå¦‚ä½•åŸºäºçº¯ç²¹çš„lambdaè¡¨è¾¾å¼å®ç°å‘¢ï¼Ÿ

** ç¬¬ä¸€æ¬¡å°è¯•

å°è¯•ç¿»è¯‘ä¹‹å‰å†™è¿‡çš„å®ç°

#+BEGIN_SRC lisp
    (lambda (ls)
      (if (null ls)
          0
          (1+ (?? (cdr ls)))))
#+END_SRC

*æ€ä¹ˆåŠ*ï¼Œ=?= éƒ¨åˆ†æ— æ³•å¡«å……ã€‚å› ä¸ºç°åœ¨è¿™ä¸ªåŒ¿åå‡½æ•°æœ¨æœ‰åå­—

*** ç¥æ¥ä¸€ç¬”

å‡å¦‚æœ‰ä¸€ä¸ªlençš„å®ç°ï¼Œä¸å°±å¯ä»¥äº†ä¹ˆï¼ï¼ï¼ï¼

#+BEGIN_SRC lisp
    (lambda (perfectLenFunc)
      (lambda (ls)
        (if (null ls)
            0
            (1+ (perfectLenFunc (cdr ls))))))
#+END_SRC

å“‡æ“¦ï¼Œè¦æ˜¯æœ‰=perfectLenFunc=(åç»­ç®€å†™ä¸º=plf=...),è¿˜åœ¨è¿™é‡Œæµªè´¹æ—¶é—´å¹²ç¥é©¬ã€‚

*å’³å’³*ï¼Œä¸æ€¥

#+BEGIN_SRC lisp
    ;; change to scheme, due to the function namespace
    (define len1
        ((lambda (plf)
        (lambda (ls)
            (if (null? ls)
                0
                (1+ (plf (cdr ls))))))
        (lambda (ls)
        (if (null? ls)
            0
            (1+ (error (cdr ls)))))))
#+END_SRC

#+BEGIN_EXAMPLE
    scheme@(guile-user)> (len1 '())
    $3 = 0
    scheme@(guile-user)> (len1 '(a))
    $4 = 1
    scheme@(guile-user)> (len1 '(a b))
    ERROR: In procedure scm-error:
    ERROR: ()
#+END_EXAMPLE

å’¦ï¼Œè¿™æ ·å°±å¯ä»¥æ”¯æŒé•¿åº¦ä¸º0çš„åˆ—è¡¨å’Œé•¿åº¦ä¸º1çš„åˆ—è¡¨å’§ã€‚

æ•´ä½“ä¼˜åŒ–ä¸€ä¸‹é‡å¤ä»£ç 

#+BEGIN_SRC lisp
    (define mk-len
      (lambda (plf)
        (lambda (ls)
            (if (null? ls)
                0
            (1+ (plf (cdr ls)))))))
    (define len0 (mk-len error))
    (define len1 (mk-len len0))
    (define len2 (mk-len len1))
    ;; output
    scheme@(guile-user)>
    (define len0 (mk-len error))
    (define len1 (mk-len len0))
    (define len2 (mk-len len1))
    scheme@(guile-user)> (len2 '(1 2))
    $6 = 2
#+END_SRC

çœ‹æ¥,åŠŸå¤«ä¸è´Ÿæœ‰å¿ƒäººï¼Œåªè¦è¶³å¤ŸåŠªåŠ›,
ä¸ç®¡å¤šé•¿çš„åˆ—è¡¨ï¼Œéƒ½èƒ½å†™å‡ºå¯¹åº”çš„å‡½æ•°ç®—å‡ºæ¥ï¼ > å¤ªå¤©çœŸäº†å°‘å¹´ ï¼ˆç”»å¤–éŸ³ï¼‰

*** ç¥åˆæ¥ä¸€ç¬”

æ—¶é—´è¿‡å»äº†ä¸€å¹´ï¼Œå°‘å¹´ç»ˆäºå†™å‡ºäº†å¯ä»¥è®¡ç®—é•¿åº¦
=14239823586=ä»¥å†…çš„åˆ—è¡¨çš„é•¿åº¦ï¼

çªç„¶ä¸€ä¸ªéœ¹é›³ä»å¤©è€Œé™ > ä½ ä¸ªXXï¼Œæƒ³å†™åˆ°æ­»å•Šï¼ï¼ï¼ï¼ (ç”»å¤–éŸ³again)

å’¦ï¼Œæ³¨æ„ =(define len0 (mk-len error))=,
=error=è€¶ï¼Œå²‚ä¸æ˜¯è¯´ä¸ç®¡æä¾›ç¥é©¬å‡½æ•°,éƒ½ ä¸å½±å“ä¹ˆ

#+BEGIN_SRC lisp
    (define len2 (mk-len (mk-len (mk-len mk-len))))
    ;; output
    scheme@(guile-user)>
    (define len2 (mk-len (mk-len (mk-len mk-len))))
    scheme@(guile-user)> (len2 '(1 2))
    $8 = 2
#+END_SRC

*å“‡ï¼Œé‚£å²‚ä¸æ˜¯å¯ä»¥è¿™æ ·ï¼ï¼ï¼*

#+BEGIN_SRC lisp
    (define real-len
      ((lambda (mk-len)
         (mk-len mk-len))
       (lambda (mk-len)
         (lambda (l)
           (if (null? l) 0
             (1+ ((mk-len mk-len) (cdr l))))))))
    scheme@(guile-user)> (real-len '(1 2 3 a b d c s))
    $9 = 8
#+END_SRC

å¥½æ£’ï¼å¥½é™¶é†‰ï¼å¥½æ»¡è¶³ï¼ï¼ï¼

*** ç¥åˆæ¥ä¸€ç¬”!

ä¸è¿‡ï¼Œå†™å‡ºæ¥çš„ç¨‹åºçœ‹ç€å¥½å¥‡æ€ªã€‚å¥½å¤š=mk-len=,=ï¼ˆmk-len mk-lenï¼‰=,
*çœ‹ä¸æ‡‚å•Š*. åªæœ‰

#+BEGIN_SRC lisp
         (lambda (l)
           (if (null? l) 0
             (1+ (?? (cdr l))))))))
#+END_SRC

è¿™ä¸ªæ‰æ˜¯æˆ‘æƒ³è¦çš„å‘¢... é‚£å°±æƒ³åŠæ³•æŠŠ=(mklen mklen)=
æå‡ºå»ï¼Œåšå‚æ•°ä¼ è¿›æ¥å¥½äº†ğŸ‘Œ

#+BEGIN_SRC lisp
    ((lambda (mk-len)
       (mk-len mk-len))
     (lambda (mk-len)
       ((lambda (len)
          (lambda (l)
            (if (null? l) 0
              (1+ (len (cdr l))))))
        (lambda (x) ((mk-len mk-len) x)))))
#+END_SRC

å“‡ï¼Œä¸­é—´çš„ä»£ç çœ‹èµ·æ¥ï¼Œæœ‰ç‚¹åƒé‚£ä¹ˆä¸€å›äº‹äº†ã€‚æƒ³åŠæ³•æŒªæŒªç»“æ„ï¼Œæ›´å¥½çœ‹ä¸€ç‚¹ã€‚

#+BEGIN_SRC lisp
    ((lambda (len')
       ((lambda (mk-len) (mk-len mk-len))
        (lambda (mk-len) (len' (lambda (x) ((mk-len mk-len) x))))))
     (lambda (len)
       (lambda (l)
         (if (null? l) 0
           (1+ (len (cdr l)))))))
#+END_SRC

*BINGO* !!

** the ultimate Y-Combinator

#+BEGIN_SRC lisp
    (define Y
      (lambda (targetFunction)
        ((lambda (f) (f f))
         (lambda (f) (targetFunction (lambda (x) ((f f) x)))))))

    (define len
      ( Y (lambda (len')
            (lambda (l)
              (if (null? l) 0
                (1+ (len' (cdr l))))))))
    ;; output
    scheme@(guile-user)> (len '(a b d c dd s sf ad f))
    $10 = 9
#+END_SRC

*ç‚«é…·çˆ†æ£šäº†!* æœ‰æ²¡æœ‰

** å®è·µ

in haskell

#+BEGIN_SRC haskell
    -- here is where miracle begins
    newtype Rec a = In { out :: Rec a -> a } -- for type deduction

    y :: (a -> a) -> a
    y tf = (\f -> out f f) $In (\f -> tf (out f f))


    ylen :: (Num b) => [a]->b
    ylen = y (\len' ls -> if null ls then 0 else (len'.tail$ls)+1)

    ysum :: (Num a) => [a] -> a
    ysum = y (\sum' ls -> if null ls then 0 else head ls + (sum'.tail $ ls))
    -- output
    Î»> ylen [1,2,3,4]
    4
    Î»> ysum [1,2,3,4]
    10
#+END_SRC

** external links

[[http://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator][y-combinator
in wikipedia]]

[[http://mitpress.mit.edu/books/little-schemer][the litter scheme -
chapter 8]]
