<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>尝试理解Y-combinator - enzo&#39;s note book</title>
    <meta charset="utf-8" />
    <meta name="author" content="enzo liu" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">enzo&#39;s note book</a></h1>
        <p>M-x (sketch for random ideas)</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/history/">History</a></li>
          <li><a href="/leetcode/">Leetcode</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/Enzo-Liu">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="//www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="blog.enzo.cc">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>尝试理解Y-combinator</h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">简介</h2>
<div class="outline-text-2" id="text-1">
<p>
在一个纯粹的函数式语言环境中，只有一种元素，就是一个单参函数
</p>

<div class="org-src-container">

<pre class="src src-lisp">;; id function
(lambda (x) x)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell">-- id function in haskll
\x -&gt; x
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">问题</h2>
<div class="outline-text-2" id="text-2">
<p>
比如需要求解一个列表的长度，该如何实现。
</p>

<p>
算法规则很简单： &gt; 1. 空列表长度为0 &gt; 2. 列表长度等于 1 +
列表除了头部元素以外的部分
</p>

<p>
常规的算法实现如下:
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">common lisp</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-lisp">;; in common lisp
(defun len (ls)
  (if (null ls)
      0
      (1+ (len (cdr ls)))))
</pre>
</div>

<pre class="example">
CL-USER&gt; (len '(1 2 3))
3
CL-USER&gt; (len '())
0
</pre>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">haskell</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">

<pre class="src src-haskell">len1 :: (Num b ) =&gt; [a] -&gt; b
len1 [] = 0
len1 (_:xs) = 1 + len1 xs
</pre>
</div>

<pre class="example">
λ&gt; len1 []
0
λ&gt; len1 [1,2,3]
3
</pre>

<p>
但是，如何基于纯粹的lambda表达式实现呢？
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">第一次尝试</h2>
<div class="outline-text-2" id="text-3">
<p>
尝试翻译之前写过的实现
</p>

<div class="org-src-container">

<pre class="src src-lisp">(lambda (ls)
  (if (null ls)
      0
      (1+ (?? (cdr ls)))))
</pre>
</div>

<p>
*怎么办*，=?= 部分无法填充。因为现在这个匿名函数木有名字
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">神来一笔</h3>
<div class="outline-text-3" id="text-3-1">
<p>
假如有一个len的实现，不就可以了么！！！！
</p>

<div class="org-src-container">

<pre class="src src-lisp">(lambda (perfectLenFunc)
  (lambda (ls)
    (if (null ls)
        0
        (1+ (perfectLenFunc (cdr ls))))))
</pre>
</div>

<p>
哇擦，要是有=perfectLenFunc=(后续简写为=plf=&#x2026;),还在这里浪费时间干神马。
</p>

<p>
*咳咳*，不急
</p>

<div class="org-src-container">

<pre class="src src-lisp">;; change to scheme, due to the function namespace
(define len1
    ((lambda (plf)
    (lambda (ls)
        (if (null? ls)
            0
            (1+ (plf (cdr ls))))))
    (lambda (ls)
    (if (null? ls)
        0
        (1+ (error (cdr ls)))))))
</pre>
</div>

<pre class="example">
scheme@(guile-user)&gt; (len1 '())
$3 = 0
scheme@(guile-user)&gt; (len1 '(a))
$4 = 1
scheme@(guile-user)&gt; (len1 '(a b))
ERROR: In procedure scm-error:
ERROR: ()
</pre>

<p>
咦，这样就可以支持长度为0的列表和长度为1的列表咧。
</p>

<p>
整体优化一下重复代码
</p>

<div class="org-src-container">

<pre class="src src-lisp">(define mk-len
  (lambda (plf)
    (lambda (ls)
        (if (null? ls)
            0
        (1+ (plf (cdr ls)))))))
(define len0 (mk-len error))
(define len1 (mk-len len0))
(define len2 (mk-len len1))
;; output
scheme@(guile-user)&gt;
(define len0 (mk-len error))
(define len1 (mk-len len0))
(define len2 (mk-len len1))
scheme@(guile-user)&gt; (len2 '(1 2))
$6 = 2
</pre>
</div>

<p>
看来,功夫不负有心人，只要足够努力,
不管多长的列表，都能写出对应的函数算出来！ &gt; 太天真了少年 （画外音）
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">神又来一笔</h3>
<div class="outline-text-3" id="text-3-2">
<p>
时间过去了一年，少年终于写出了可以计算长度
=14239823586=以内的列表的长度！
</p>

<p>
突然一个霹雳从天而降 &gt; 你个XX，想写到死啊！！！！ (画外音again)
</p>

<p>
咦，注意 <code>(define len0 (mk-len error))</code>,
=error=耶，岂不是说不管提供神马函数,都 不影响么
</p>

<div class="org-src-container">

<pre class="src src-lisp">(define len2 (mk-len (mk-len (mk-len mk-len))))
;; output
scheme@(guile-user)&gt;
(define len2 (mk-len (mk-len (mk-len mk-len))))
scheme@(guile-user)&gt; (len2 '(1 2))
$8 = 2
</pre>
</div>

<p>
<b>哇，那岂不是可以这样！！！</b>
</p>

<div class="org-src-container">

<pre class="src src-lisp">(define real-len
  ((lambda (mk-len)
     (mk-len mk-len))
   (lambda (mk-len)
     (lambda (l)
       (if (null? l) 0
         (1+ ((mk-len mk-len) (cdr l))))))))
scheme@(guile-user)&gt; (real-len '(1 2 3 a b d c s))
$9 = 8
</pre>
</div>

<p>
好棒！好陶醉！好满足！！！
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">神又来一笔!</h3>
<div class="outline-text-3" id="text-3-3">
<p>
不过，写出来的程序看着好奇怪。好多=mk-len=,=（mk-len mk-len）=,
<b>看不懂啊</b>. 只有
</p>

<div class="org-src-container">

<pre class="src src-lisp">(lambda (l)
  (if (null? l) 0
    (1+ (?? (cdr l))))))))
</pre>
</div>

<p>
这个才是我想要的呢&#x2026; 那就想办法把=(mklen mklen)=
搞出去，做参数传进来好了👌
</p>

<div class="org-src-container">

<pre class="src src-lisp">((lambda (mk-len)
   (mk-len mk-len))
 (lambda (mk-len)
   ((lambda (len)
      (lambda (l)
        (if (null? l) 0
          (1+ (len (cdr l))))))
    (lambda (x) ((mk-len mk-len) x)))))
</pre>
</div>

<p>
哇，中间的代码看起来，有点像那么一回事了。想办法挪挪结构，更好看一点。
</p>

<div class="org-src-container">

<pre class="src src-lisp">((lambda (len')
   ((lambda (mk-len) (mk-len mk-len))
    (lambda (mk-len) (len' (lambda (x) ((mk-len mk-len) x))))))
 (lambda (len)
   (lambda (l)
     (if (null? l) 0
       (1+ (len (cdr l)))))))
</pre>
</div>

<p>
<b>BINGO</b> !!
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">the ultimate Y-Combinator</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">

<pre class="src src-lisp">(define Y
  (lambda (targetFunction)
    ((lambda (f) (f f))
     (lambda (f) (targetFunction (lambda (x) ((f f) x)))))))

(define len
  ( Y (lambda (len')
        (lambda (l)
          (if (null? l) 0
            (1+ (len' (cdr l))))))))
;; output
scheme@(guile-user)&gt; (len '(a b d c dd s sf ad f))
$10 = 9
</pre>
</div>

<p>
<b>炫酷爆棚了!</b> 有没有
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">实践</h2>
<div class="outline-text-2" id="text-5">
<p>
in haskell
</p>

<div class="org-src-container">

<pre class="src src-haskell">-- here is where miracle begins
newtype Rec a = In { out :: Rec a -&gt; a } -- for type deduction

y :: (a -&gt; a) -&gt; a
y tf = (\f -&gt; out f f) $In (\f -&gt; tf (out f f))


ylen :: (Num b) =&gt; [a]-&gt;b
ylen = y (\len' ls -&gt; if null ls then 0 else (len'.tail$ls)+1)

ysum :: (Num a) =&gt; [a] -&gt; a
ysum = y (\sum' ls -&gt; if null ls then 0 else head ls + (sum'.tail $ ls))
-- output
λ&gt; ylen [1,2,3,4]
4
λ&gt; ysum [1,2,3,4]
10
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">external links</h2>
<div class="outline-text-2" id="text-6">
<p>
<a href="http://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator">y-combinator
in wikipedia</a>
</p>

<p>
<a href="http://mitpress.mit.edu/books/little-schemer">the litter scheme -
chapter 8</a>
</p>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2015-03-20</span>
        <span title="last modification date" class="post-info">2016-02-03</span>
        <span title="tags" class="post-info"><a href="/tags/lisp/">lisp</a>, <a href="/tags/haskell/">haskell</a>, <a href="/tags/y-combinator/">y-combinator</a>, <a href="/tags/lambda/">lambda</a></span>
        <span title="author" class="post-info">enzo liu</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2015/03/20/尝试理解y-combinator/";
          var disqus_url = "https://blog.enzo.cc/blog/2015/03/20/尝试理解y-combinator/";
          var disqus_shortname = 'enzo-liu';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x (<a href="http://orgmode.org">Org mode</a> 8.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:liuenze6516 &lt;at&gt; gmail &lt;dot&gt; com">enzo liu</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
